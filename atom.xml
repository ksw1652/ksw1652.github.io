<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gamjamanduu의 블로그</title>
  
  <subtitle>gamjamanduu의 블로그</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ksw1652.github.io/"/>
  <updated>2019-03-21T09:06:29.911Z</updated>
  <id>http://ksw1652.github.io/</id>
  
  <author>
    <name>gamjamanduu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>함수형 자바스크립트 스터디 내용정리 (Chapter3)</title>
    <link href="http://ksw1652.github.io/2019/03/15/%ED%95%A8%EC%88%98%ED%98%95%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Javascript-Chapter3/"/>
    <id>http://ksw1652.github.io/2019/03/15/함수형프로그래밍-Javascript-Chapter3/</id>
    <published>2019-03-15T06:38:16.000Z</published>
    <updated>2019-03-21T09:06:29.911Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><p><em>본 포스트의 내용은 <strong>FUNCTIONAL PROGRAMMING IN JAVASCRIPT (함수형 자바스크립트)</strong> 교재의 스터디 내용을 기반으로 작성하였습니다</em></p><h3 id="이-장의-내용"><a href="#이-장의-내용" class="headerlink" title="이 장의 내용"></a>이 장의 내용</h3><blockquote><ul><li>자료구조를 순차적으로 탐색/변환하는 데 쓰이는 실용적인 연산들(map, reduce, filter)</li><li>로대시JS</li><li>함수형 프로그래밍에서 재귀의 중요성</li></ul></blockquote><!-- 이 장에서는 자료구조를 순차적으로 탐색/변환하는 데 쓰이는 실용적인 연산 몇가지 (map, reduce, filter)를 소개합니다. 이들은 사실상 모든 함수형 프로그램이 나름대로 응용해서 쓰기 때문에 매우 중요한 함수입니다. 대부분의 루프는 이들이 처리하는 하나의 특정 케이스에 지나지 않으므로 코드에서 수동 루프를 없앨 목적으로도 쓰입니다.또한 로대시JS의 사용법을 배웁니다. 애플리케이션의 구조는 물론 자료구조도 처리하고 이해할 수 있게 해주는 함수형 자바스크립트 라이브러리입니다. 또 FP에서 재귀가 차지하는 막대한 비중에 대해 알아보고 재귀적인 사고방식이 어떤 점에서 좋은지 설명합니다. 이런 개념들이 밑거름이 되어야 코드의 메인 로직에서 제어 흐름을 명확하게 분리하여 간결하고 확장성 좋은, 선언적 프로그램을 작성할 수 있습니다. --><h2 id="3-1-애플리케이션의-제어-흐름"><a href="#3-1-애플리케이션의-제어-흐름" class="headerlink" title="3.1 애플리케이션의 제어 흐름"></a>3.1 애플리케이션의 제어 흐름</h2><p>프로그램이 정답에 이르기까지 거치는 경로를 <strong>제어흐름(control flow)</strong>이라고 합니다. 명령형 프로그램은 작업 수행에 필요한 전 단계를 노출하여 흐름이나 경로를 아주 자세히 서술합니다. 명령형 프로그램의 틀을 고수준에서 바라보면 다음 코드와 같습니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loop = opt();</span><br><span class="line">white(loop) {</span><br><span class="line">  <span class="keyword">var</span> condition = optA();</span><br><span class="line">  <span class="keyword">if</span>(condition) {</span><br><span class="line">    optB1();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    optB2();</span><br><span class="line">  }</span><br><span class="line">  loop = optC();</span><br><span class="line">}</span><br><span class="line">optD();</span><br></pre></td></tr></tbody></table></figure></div></figure><p>[그림 3-1]은 간단히 표현한 프로그램의 흐름도입니다.</p><div class="figure center" style="width:100%;"><a class="fancybox" href="picture_3-1.png" title="그림3-1 명령형 프로그램은 분기, 루프에 따라 움직이는 일련의 연산(구문)들로 구성됩니다." data-caption="그림3-1 명령형 프로그램은 분기, 루프에 따라 움직이는 일련의 연산(구문)들로 구성됩니다." data-fancybox="FunctionalPrograming_chapter3"><img class="fig-img" src="picture_3-1.png" style="width:100%;height:100%;" alt="그림3-1 명령형 프로그램은 분기, 루프에 따라 움직이는 일련의 연산(구문)들로 구성됩니다."></a><span class="caption">그림3-1 명령형 프로그램은 분기, 루프에 따라 움직이는 일련의 연산(구문)들로 구성됩니다.</span></div><div style="clear:both;"></div><p>반면 선언적 프로그램, 특히 함수형 프로그램은 독립적인 <strong>블랙박스</strong> 연산들이 단순하게, 즉 최소한의 제어구조를 통해 연결되어 추상화 수준이 높습니다. 이렇게 연결한 연산들은 각자 다음 연산으로 상태를 이동시키는 고계함수에 불과합니다. 실제로 함수형 프로그램은 데이터와 제어 흐름 자체를 고수준 컴포넌트 사이의 단순한 연결로 취급합니다.</p><div class="figure center" style="width:100%;"><a class="fancybox" href="picture_3-2.png" title="그림3-2 함수형 프로그램은 서로 연결된 블랙박스 연산을 제어합니다. 정보는 한 연산에서 다른 연산으로 독립적으로 흘러가며, 분기와 반복은 상당 부분 줄이거나 아예 없애고 고수준의 추상화로 대체합니다." data-caption="그림3-2 함수형 프로그램은 서로 연결된 블랙박스 연산을 제어합니다. 정보는 한 연산에서 다른 연산으로 독립적으로 흘러가며, 분기와 반복은 상당 부분 줄이거나 아예 없애고 고수준의 추상화로 대체합니다." data-fancybox="FunctionalPrograming_chapter3"><img class="fig-img" src="picture_3-2.png" style="width:100%;height:100%;" alt="그림3-2 함수형 프로그램은 서로 연결된 블랙박스 연산을 제어합니다. 정보는 한 연산에서 다른 연산으로 독립적으로 흘러가며, 분기와 반복은 상당 부분 줄이거나 아예 없애고 고수준의 추상화로 대체합니다."></a><span class="caption">그림3-2 함수형 프로그램은 서로 연결된 블랙박스 연산을 제어합니다. 정보는 한 연산에서 다른 연산으로 독립적으로 흘러가며, 분기와 반복은 상당 부분 줄이거나 아예 없애고 고수준의 추상화로 대체합니다.</span></div><div style="clear:both;"></div><p>덕분에 다음과 같이 코드가 짧아집니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optA().optB().optC().optD();    <span class="comment">//점으로 연결하려면 이들 메서드가 모두 포함된 공유 객체가 있어야 합니다.</span></span><br></pre></td></tr></table></figure></p><h2 id="3-2-메서드-체이닝"><a href="#3-2-메서드-체이닝" class="headerlink" title="3.2 메서드 체이닝"></a>3.2 메서드 체이닝</h2><p><strong>메서드 체이닝(method chaining)</strong>은 여러 메서드를 단일 구문으로 호출하는 OOP패턴입니다. 메서드가 모두 동일한 객체에 속해 있으면 <strong>메서드 흘리기(method cascading)</strong>라고도 합니다. 대부분 객체지향 프로그램에서 불변 객체에 많이 적용하는 패턴이지만 함수형 프로그래밍에도 잘 맞습니다. 문자열을 다루는 예제 하나를 봅시다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat(toLowerCase(substring(<span class="string">'Functional Programming'</span>, <span class="number">1</span>, <span class="number">10</span>)), <span class="string">' is fun'</span>);</span><br></pre></td></tr></table></figure><p>매개변수는 모두 함수 선언부에 명시해서 부수효과를 없애고 원본 객체를 바꾸지 않아야 한다는 함수형 교리를 충실히 반영한 코드입니다. 그러나 이렇게 함수 코드를 안쪽에서 바깥쪽으로 작성하면 메서드 체이닝 방식만큼 매끄럽지 못합니다. 로직을 파악하려면 가장 안쪽에 감싼 함수부터 한 꺼풀씩 벗겨내야 하고 가독성도 현저히 떨어지지요.</p><p>변이를 일으키지 않는 한 함수형 프로그래밍에서도 단일 객체 인스턴스에 속한 메서드를 체이닝하는 건 나름대로 쓸모가 있습니다. 자바스크립트 배열에도 문자열 객체에 메서드를 체이닝하는 패턴을 확장시켜 적용할 수는 있지만, 안타깝게도 많은 사람이 익숙하지 않은 탓에 머릿속에 떠오르는 지저분한 루프를 다시 꺼내 쓰기 쉽습니다.</p><h2 id="3-3-함수-체이닝"><a href="#3-3-함수-체이닝" class="headerlink" title="3.3 함수 체이닝"></a>3.3 함수 체이닝</h2><p>객체지향 프로그램은 주로 상속을 통해 코드를 재사용합니다. 순수 객체지향 언어에서, 특히 언어 자체의 자료구조를 구현한 코드를 보면 이런 패턴이 자주 눈에 띕니다. 가령 자바에는 List 인터페이스를 용도에 맞게 구현한 ArrayList, LinkedList, DoublyLinkedList, CopyOnWriteArrayList 등이 있습니다. 이들은 모두 한 부모에서 출발하여 나름대로 특수한 기능을 덧붙인 클래스입니다.</p><p>FP는 접근 방법이 다릅니다. 자료구조를 새로 만들어 어떤 요건을 충족시키는게 아니라, 배열 등의 흔한 자료구조를 이용해 다수의 굵게 나뉜 고계 연산을 적용합니다. 이러한 고계 연산으로 다음과 같은 일을 합니다.</p><blockquote><p>작업을 수행하기 위해 무슨 일을 해야 하는지 기술된 함수를 인수로 받습니다.</p></blockquote><blockquote><p>임시 변수의 값을 계속 바꾸면서 부수효과를 일으키는 기존 수동 루프를 대체합니다. 그 결과 관리할 코드가 줄고 에러가 날 만한 코드 역시 줄어듭니다.</p></blockquote><p>좀 더 자세히 살펴보기 위해 Person 객체의 컬렉션을 기준으로 테스트 객체를 만들어 보겠습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Haskell'</span>, <span class="string">'Curry'</span>, <span class="string">'111-11-1111'</span>);</span><br><span class="line">p1.address = <span class="keyword">new</span> Address(<span class="string">'US'</span>);</span><br><span class="line">p1.birthYear = <span class="number">1900</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person(<span class="string">'Barkley'</span>, <span class="string">'Rosser'</span>, <span class="string">'222-22-2222'</span>);</span><br><span class="line">p2.address = <span class="keyword">new</span> Address(<span class="string">'Greece'</span>);</span><br><span class="line">p2.birthYear = <span class="number">1907</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> Person(<span class="string">'John'</span>, <span class="string">'von Neumann'</span>, <span class="string">'333-33-3333'</span>);</span><br><span class="line">p3.address = <span class="keyword">new</span> Address(<span class="string">'Hungary'</span>);</span><br><span class="line">p3.birthYear = <span class="number">1903</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p4 = <span class="keyword">new</span> Person(<span class="string">'Alonzo'</span>, <span class="string">'Church'</span>, <span class="string">'444-44-4444'</span>);</span><br><span class="line">p4.address = <span class="keyword">new</span> Address(<span class="string">'US'</span>);</span><br><span class="line">p4.birthYear = <span class="number">1903</span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-1-람다-표현식"><a href="#3-3-1-람다-표현식" class="headerlink" title="3.3.1 람다 표현식"></a>3.3.1 람다 표현식</h3><p>함수형 프로그래밍에서 탄생한 <strong>람다 표현식(lamda expression)</strong> (자바스크립트에서는 <strong>두 줄 화살표 함수(fat-arrow function)</strong> 라고도 함)은 한 줄짜리 익명 함수를 일반 함수 선언보다 단축된 구문으로 나타냅니다. 람다 함수는 여러 줄로도 표기할 수 있지만, 2장에서 보았듯이 거의 대부분 한 줄로 씁니다. 사람 이름을 추출하는 간단한 예제를 봅시다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="function"><span class="params">p</span> =&gt;</span> p.fullname;</span><br><span class="line"><span class="built_in">console</span>.log(name(p1)); <span class="comment">//-&gt; 'Haskell Curry'</span></span><br></pre></td></tr></table></figure></p><p>(p) =&gt; p.fullname은 매개변수 p를 받아 p.fullname을 반환하는 간편 구문입니다. 자세한 구문 구조는 [그림 3-3]을 참고하세요</p><div class="figure center" style="width:100%;"><a class="fancybox" href="picture_3-3.png" title="그림3-3 화살표 함수의 해부도. 람다 함수 우변에는 단일 표현식이나 여러 구문이 포함된 블록이 옵니다." data-caption="그림3-3 화살표 함수의 해부도. 람다 함수 우변에는 단일 표현식이나 여러 구문이 포함된 블록이 옵니다." data-fancybox="FunctionalPrograming_chapter3"><img class="fig-img" src="picture_3-3.png" style="width:100%;height:100%;" alt="그림3-3 화살표 함수의 해부도. 람다 함수 우변에는 단일 표현식이나 여러 구문이 포함된 블록이 옵니다."></a><span class="caption">그림3-3 화살표 함수의 해부도. 람다 함수 우변에는 단일 표현식이나 여러 구문이 포함된 블록이 옵니다.</span></div><div style="clear:both;"></div><p>람다 표현식은 항상 어떤 값을 반환하게 만들어 함수 정의부를 확실히 함수형으로 굳힙니다. 한 줄짜리 표현식의 반환값은 함수 본체를 실행한 결과값입니다. 여기서 주목할 점은 일급 함수와 람다 표현식의 관계입니다. 위 예제에서 name은 실제하는 값이 아니라, 그 값을 얻기 위한 (느긋한) 방법을 가리킵니다. 즉 name으로 데이터를 계산하는 로직이 담긴 두 줄 화살표 함수를 가리키는 것입니다. 함수형 프로그램은 이렇게 함수를 마치 값처럼 쓸 수 있습니다.</p><p>함수형 프로그래밍은 람다 표현식과 잘 어울리는 세 주요 고계함수 map, reduce, filter를 적극 사용할 것을 권장합니다. 사실 함수형 자바스크립트는 대부분 자료 리스트를 처리하는 코드 입니다. 함수형 배열 연산을 지원하는 array extras 함수는 ES5에도 있지만 필자는 이와 유사한 다른 유형의 연산까지 포괄하는 <strong>완전한 솔루션</strong>을 만들기 위해 <code>로대시JS(lodashJS)</code>라는 함수형 라이브러리를 쓰겠습니다. 로대시JS는 개발자가 함수형 프로그램을 작성하도록 유도하는 중요한 장치를 제공하고, 여러 가지 공통적인 프로그래밍 작업을 처리하는데 유용한 도우미 함수들을 풍성하게 지원합니다. 라이브러리 설치 후 전역 객체 <code>_</code> (언더스코어 또는 로대시라고 읽음)를 통해 로대시JS 함수를 꺼내 쓰면 됩니다. 그럼 _.map()부터 시작합니다.</p><p><strong>로대시JS 속 언더스코어</strong><br><div class="alert info no-icon"><p>로대시JS는 언더스코어라는 유명 프로젝트에서 파생된 라이브러리 이므로 언더스코어JS의 관례를 따릅니다. 현재도 로대시JS는 언더스코어JS대신 그냥 써도 무방할 정도로 언더스코어 API를 충실히 반영해왔습니다. 하지만 내부적으로는 함수 체인을 좀 더 우아하게 구축하는 방향으로 완전히 재작성되었고, 7장에서 다룰 성능 문제도 개선된 라이브러리입니다.</p></div></p><h3 id="3-3-2-map-데이터를-반환"><a href="#3-3-2-map-데이터를-반환" class="headerlink" title="3.3.2 _.map: 데이터를 반환"></a>3.3.2 _.map: 데이터를 반환</h3><p>덩치 큰 데이터 컬렉션의 원소를 모두 변환해야 할 때가 있습니다. 예를 들어 학생 리스트에서 각자의 성명을 추출한다고 합시다. 이런 코드를 다음과 같이 구현했던 적이 부지기수였겠죠?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">var</span> persions = [p1, p2, p3, p4];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; persion.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> p = persions[i];</span><br><span class="line">  <span class="keyword">if</span>(p !== <span class="literal">null</span> &amp;&amp; p !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    result.push(p.fullname);    <span class="comment">//명령형 관점에서는 fullname이 Student의 메서드입니다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map(collect라고도 합니다)은 <strong>배열 각 원소에 이터레이터 함수를 적용하여 크기가 같은 새 배열을 반환하는 고계함수</strong>입니다. _.map을 써서 함수형 스타일로 바꿔볼까요?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.map(persons, s =&gt; (s !== <span class="literal">null</span> &amp;&amp; s !== <span class="literal">undefined</span>) ? s.fullname : <span class="string">''</span>);</span><br></pre></td></tr></table></figure><p>map연산을 수학적으로 쓰면 다음과 같습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map(f, [e0, e1, e2...]) -&gt; [r0, r1, r2...];</span><br><span class="line">여기서 f(en) = rn</span><br></pre></td></tr></table></figure></p><p>map 함수는 루프를 쓰거나 괴팍한 스코프 문제를 신경 쓸 필요 없이 컬렉션의 원소를 전부 파싱할 경우 아주 유용합니다. 항상 새로운 배열을 반환하므로 불변성도 간직되지요. map은 함수 f와 n개의 원소가 담긴 컬렉션을 받아 왼쪽 -&gt; 오른쪽 방향으로 각 원소에 f를 적용한 계산 결과를, 역시 크기가 n인 새 배열에 담아 반환합니다. [그림 3-4]가 이 과정을 보여줍니다.<br><div class="figure center" style="width:100%;"><a class="fancybox" href="picture_3-4.png" title="그림 3-4 연산은 배열 원소에 각각 이터레이터 함수 f를 실행한 결과값을 동일한 크기의 배열에 담아 반환합니다." data-caption="그림 3-4 연산은 배열 원소에 각각 이터레이터 함수 f를 실행한 결과값을 동일한 크기의 배열에 담아 반환합니다." data-fancybox="FunctionalPrograming_chapter3"><img class="fig-img" src="picture_3-4.png" style="width:100%;height:100%;" alt="그림 3-4 연산은 배열 원소에 각각 이터레이터 함수 f를 실행한 결과값을 동일한 크기의 배열에 담아 반환합니다."></a><span class="caption">그림 3-4 연산은 배열 원소에 각각 이터레이터 함수 f를 실행한 결과값을 동일한 크기의 배열에 담아 반환합니다.</span></div><div style="clear:both;"></div></p><p>예제에서 _.map은 배열을 반복하며 각 학생의 이름을 얻습니다. 이터레이터 함수는 일반적으로 람다 표현식으로 나타냅니다. 연산이 끝나면, 원본 배열은 건드리지 않은 채 다음 원소가 포함된 새 배열이 반환됩니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'Haskell Curry'</span>, <span class="string">'Barkley Rosser'</span>, <span class="string">'John von Neumann'</span>, <span class="string">'Alonzo Church'</span>]</span><br></pre></td></tr></table></figure></p><p>추상화 내부를 알면 이해하는데 도움이 될 테니 _.map을 구현한 [코드 3-1]을 봅시다.<br><figure class="codeblock codeblock--tabbed"><figcaption><span>코드 3-1 map 구현부</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">arr, fn</span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> len = arr.length,</span><br><span class="line">        result = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> idx = <span class="number">0</span>; idx &lt; len; idx++) {</span><br><span class="line">    result[idx] = fn(arr[idx], idx, arr);</span><br><span class="line">  }      </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><br>위 코드를 보면 _.map도 안에서는 일반 루프를 씁니다. _.map이 반복을 대행하는 덕분에 개발자는 루프 변수를 하나씩 늘리며 경계 조건을 체크하는 등의 따분한 일은 이 함수에게 맡기고 이터레이터 함수에 구현한 비즈니스 로직만 신경쓰면 됩니다. 이렇듯 함수형 라이브러리를 쓰면 기존 코드도 진짜 순수 함수형 언어처럼 변신시킬 수 있습니다.</p><p>로대시JS는 일관성을 유지하기 위해 자바스크립트의 Array.reverse()에 해당하는 _.reverse() 메서드를 지원합니다. 이 함수는 원본 배열에 변이를 일으키므로 개발자는 부수효과가 언제 일어날지 알고 있어야 합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_(persons).reverse().map(</span><br><span class="line">  p =&gt; (p != <span class="literal">null</span> &amp;&amp; p != <span class="literal">undefined</span>) ? p.fullname : <span class="string">''</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>못 보던 구문이 눈에 띄네요. 로대시JS는 기존 코드에 영향을 주지 않으면서도 쉽게 통합할 수 있는 멋진 방법을 제공합니다. 원하는 객체를 일단 _(…)로 감싸면 로대시JS의 강력한 함수형 도구를 이용해 마음껏 변환할 수 있습니다.</p><p>지금까지 데이터를 변환하는 함수를 적용해보았고, 다음은 새로운 자료구조에 기반을 둔 값으로 귀결시키는 reduce 함수를 살펴보겠습니다.</p><h3 id="3-3-3-reduce-결과를-수집"><a href="#3-3-3-reduce-결과를-수집" class="headerlink" title="3.3.3 _.reduce: 결과를 수집"></a>3.3.3 _.reduce: 결과를 수집</h3><p>데이터를 변환한 후에는 변환된 데이터로부터 의미있는 결과를 도출하고 싶을때 reduce함수를 사용합니다.</p><p>reduce는 원소 배열을 하나의 값으로 짜내는 고계함수로, 원소마다 함수를 실행한 결과값의 누적치를 계산합니다. 그림으로 보면 이해가 더 빠릅니다.<br><div class="figure center" style="width:100%;"><a class="fancybox" href="picture_3-5.png" title="그림 3-5 배열을 단일 값으로 리듀스 하는 과정. 앞 단계의 결과값에 현 단계의 결과값을 누적하고 배열 끝에 이를 때까지 반복합니다. 반드시 하나의 값으로 귀결됩니다." data-caption="그림 3-5 배열을 단일 값으로 리듀스 하는 과정. 앞 단계의 결과값에 현 단계의 결과값을 누적하고 배열 끝에 이를 때까지 반복합니다. 반드시 하나의 값으로 귀결됩니다." data-fancybox="FunctionalPrograming_chapter3"><img class="fig-img" src="picture_3-5.png" style="width:100%;height:100%;" alt="그림 3-5 배열을 단일 값으로 리듀스 하는 과정. 앞 단계의 결과값에 현 단계의 결과값을 누적하고 배열 끝에 이를 때까지 반복합니다. 반드시 하나의 값으로 귀결됩니다."></a><span class="caption">그림 3-5 배열을 단일 값으로 리듀스 하는 과정. 앞 단계의 결과값에 현 단계의 결과값을 누적하고 배열 끝에 이를 때까지 반복합니다. 반드시 하나의 값으로 귀결됩니다.</span></div><div style="clear:both;"></div></p><p>[그림 3-5]를 수학적으로 쓰면 다음과 같습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [e0, e1, e2, e3]. accum) -&gt; f(f(f(f(accum, e0), e1), e2), e3) -&gt; R</span><br></pre></td></tr></table></figure></p><p>[코드 3-2]는 reduce를 간단히 구현한 코드입니다.<br><figure class="codeblock codeblock--tabbed"><figcaption><span>코드 3-2 reduce 구현부</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">arr, fn, accumulator</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> idx = <span class="number">-1</span>,</span><br><span class="line">      len = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!accumulator &amp;&amp; len &gt; <span class="number">0</span>) {    <span class="comment">//누산치를 지정하지 않으면 배열의 첫번째 원소를 초기값으로 삼습니다.</span></span><br><span class="line">    accumulator = arr[++idx];</span><br><span class="line">  }    </span><br><span class="line"></span><br><span class="line">  white (++idx &lt; len) {</span><br><span class="line">    accumulator = fn(accumulator, arr[idx], arr);    <span class="comment">//배열을 반복하면서 원소마다 누산치, 현재 값, 인덱스, 배열을 인수로 fn을 실행합니다.</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> accumulator;    <span class="comment">//단일 누산치를 반복합니다.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure></p><p>reduce는 다음 매개변수를 받습니다.</p><ul><li>fn : 배열 각 원소마다 실행할 이터레이터 함수로, 매개변수는 누산치, 현재 값, 인덱스, 배열입니다.</li><li>accumulator : 계산할 초깃값으로 넘겨받는 인수이고, 함수 호출을 거치며 매 호출 시 계산된 결과값을 저장하는데 쓰입니다.</li></ul><p>Person 객체 컬렉션에서 국가별 인구 등 유용한 통계치를 산출하는 프로그램을 작성해봅시다. 먼저 국가별 인구를 계산하는 코드입니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>코드 3-3 국가별 인구 계산</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_(persons).reduce(<span class="function">(<span class="params">stat, person</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> country = person.address.country;    <span class="comment">//거주 국가를 얻습니다.</span></span><br><span class="line">  stat[country] = _.isUndefined(stat[country]) ? <span class="number">1</span> : stat[country] + <span class="number">1</span>;    <span class="comment">//country는 1로 초기화 한 후, 해당 국가에 거주하는 사람이 있을 때마다 하나씩 더합니다.</span></span><br><span class="line">  <span class="keyword">return</span> stat;   <span class="comment">//누적 객체를 반환합니다.</span></span><br><span class="line">}, {});    <span class="comment">//빈 객체로 리듀스를 시작합니다. (누산치 초기화)</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>코드를 실행하면 주어진 Person 배열을 토대로 국가별 인구를 산출하여 다음과 같이 단일 객체에 담습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'US'</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="string">'Greece'</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="string">'Hungary'</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>많이 쓰이는 맵-리듀스 조합을 이용하면 작업을 더 단순화할 수 있습니다. 원하는 기능을 map, reduce 두 함수에 매개변수로 담아 보내고 이들을 연결해서 기능을 확장하는 겁니다. 대략 다음과 같은 흐름입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_(persons).map(func1).reduce(func2);</span><br></pre></td></tr></table></figure><p>여기서 원하는 작업을 func1, func2 함수에 각각 구현합니다. 다음 코드처럼 주요 흐름에서 함수를 떼어내 별도로 만드는 거죠.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>코드 3-4 map과 reduce를 조합하여 통계치를 산출</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getCountry = <span class="function"><span class="params">person</span> =&gt;</span> person.address.country;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gatherStats = <span class="function"><span class="keyword">function</span> (<span class="params">stat, criteria</span>) </span>{</span><br><span class="line">  stat[criteria] = _.isUndefined(stat[criteria]) ? <span class="number">1</span> : stat[criteria] + <span class="number">1</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">_(persons).map(getCountry).reduce(gatherStats, {});</span><br></pre></td></tr></tbody></table></figure></div></figure><p>map으로 객체 배열을 처리하여 국가 정보를 뽑아낸 다음, reduce로 최종 결과를 수집합니다. [코드 3-3]과 결과는 같지만, 훨씬 깔끔하고 확장 가능한 모양새입니다. 속성을 직접 건드리는 대신 (람다JS로) Person 객체의 address.city 속성에 초점을 맞춘 렌즈를 써봅시다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cityPath = [<span class="string">'address'</span>, <span class="string">'city'</span>];</span><br><span class="line"><span class="keyword">const</span> cityLens = R.lens(R.path(cityPath), R.assocPath(cityPath));</span><br></pre></td></tr></table></figure><p>거주 도시별 인구를 산출하는 작업도 마찬가지로 어렵지 않습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_(persons).map(R.view(cityLens)).reduce(gatherStats, &#123;&#125;);</span><br></pre></td></tr></table></figure><p>_.groupBy를 쓰면 코드가 훨씬 간명해 집니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.groupBy(persons, R.view(cityLens));</span><br></pre></td></tr></table></figure><p>map과 달리 reduce는 누산치에 의존하기 때문에 결합법칙이 성립하지 않는 연산은 진행순서 (왼쪽 -&gt; 오른쪽 또는 오른쪽 -&gt; 왼쪽)에 따라 결과가 달라집니다. 나눗셈 같은 연산은 결과가 완전히 달라지죠.</p><p>_.reduceRight를 수학적으로 쓰면 다음과 같습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduceRight(f, [e0, e1, e2], accum) -&gt; f(e0, f(e1, f(e2, f(e3, accum)))) -&gt; R</span><br></pre></td></tr></table></figure><p>_.divide로 나눗셈을 하는 다음 두 연산은 결과가 판이합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]).reduce(_.divide) !== ([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]).reduceRight(_.divide);</span><br></pre></td></tr></table></figure></p><p>또 reduce는 <strong>일괄적용(apply-to-all)</strong> 연산이라서 배열을 순회하는 도중 그만두고 나머지 원소를 생략할 방법이 없습니다. 가령 어떤 입력값 리스트를 검증하는 경우, 검증 결과를 하나의 불리언 값으로 리듀스하면 입력값이 전부 올바른지 알아낼 수있을 것입니다.</p><p>하지만 <strong>reduce는 리스트 값을 빠짐없이 방문</strong>하기 때문에 다소 비효율적입니다. 잘못된 입력값이 하나라도 발견되면 나머지 값들은 더 이상 체크할 필요가 없으니까요. 앞으로 여러분이 애용하게 될 _.some, _.isUndefined, _.isNull 같은 함수를 써서 좀 더 효율적인 검증기를 만들어 보겠습니다. 각 원소에 _.some 함수를 실행하면 주어진 조건을 만족하는 값이 발견되는 즉시 true를 반환합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotValid = <span class="function"><span class="params">val</span> =&gt;</span> _.isUndefined(val) || _.isNull(val);    <span class="comment">//undefined, null은 올바른 값이 아닙니다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> notAllValid = <span class="function"><span class="params">args</span> =&gt;</span> _(args).some(isnotValid);   <span class="comment">//하나라도 true면 some함수를 즉시 반환합니다. 최소한 하나의 값이라도 올바른지 확인할 때 유용합니다.</span></span><br><span class="line"></span><br><span class="line">notAllValid([<span class="string">'string'</span>, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">undefined</span>]);    <span class="comment">//-&gt; true</span></span><br><span class="line">notAllValid([<span class="string">'string'</span>, <span class="number">0</span>, &#123;&#125;]);   <span class="comment">//-&gt; false</span></span><br></pre></td></tr></table></figure><p>notAllValid의 논리적 역함수 allValid는 주어진 술어가 모든 원소에 대해 true인지 _.every로 체크합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isValid = <span class="function"><span class="params">val</span> =&gt;</span> !_.isUndefined(val) &amp;&amp; !_.isNull(val);</span><br><span class="line"><span class="keyword">const</span> allValid = <span class="function"><span class="params">args</span> =&gt;</span> _(args).every(isValid);</span><br><span class="line"></span><br><span class="line">allValid([<span class="string">'string'</span>, <span class="number">0</span>, <span class="literal">null</span>])   <span class="comment">//-&gt; false</span></span><br><span class="line">allValid([<span class="string">'string'</span>, <span class="number">0</span>, &#123;&#125;])   <span class="comment">//-&gt; true</span></span><br></pre></td></tr></table></figure></p><p>map과 reduce는 배열 원소를 모두 탐색한다고 했습니다. 자료구조의 원소를 다 처리하지 않고 null이나 undefined인 객체는 건너뛰어야 할 경우도 있겠죠. 계산을 시작하기 전에 특정 원소는 미리 솎아낼 수단이 있으면 좋겠습니다. 바로 이런 일을 하는게 _.filter 입니다.</p><h3 id="3-3-4-filter-원하지-않는-원소를-제거"><a href="#3-3-4-filter-원하지-않는-원소를-제거" class="headerlink" title="3.3.4 _.filter: 원하지 않는 원소를 제거"></a>3.3.4 _.filter: 원하지 않는 원소를 제거</h3><p>큰 데이터 컬렉션을 처리할 경우, 계산하지 않을 원소는 사전에 빼는게 좋습니다. 예컨대, 특정 년도 출생자나 유럽 거주자 인구만을 산출할 때, if-else 문을 남발하는 대신 _.filter를 쓰면 한결 코드가 깔끔해집니다.</p><p><strong>filter(select라고도 합니다)는 배열 원소를 반복하면서 술어 함수 p가 true를 반환하는 원소만 추려내고 그 결과를 새 배열에 담아 반환하는 고계함수입니다.</strong> 수학적으로 쓰면 다음과 같습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(p, [d0, d1, d2, d3... dn]) -&gt; [d0, d1,... dn] (원래 집합의 부분집합)</span><br></pre></td></tr></table></figure><div class="figure center" style="width:100%;"><a class="fancybox" href="picture_3-6.png" title="그림 3-6 필터는 주어진 배열 원소에 선별 기준을 나타내는 함수형 술어 p를 적용 후, 원래 배열의 부분집합을 돌려줍니다." data-caption="그림 3-6 필터는 주어진 배열 원소에 선별 기준을 나타내는 함수형 술어 p를 적용 후, 원래 배열의 부분집합을 돌려줍니다." data-fancybox="FunctionalPrograming_chapter3"><img class="fig-img" src="picture_3-6.png" style="width:100%;height:100%;" alt="그림 3-6 필터는 주어진 배열 원소에 선별 기준을 나타내는 함수형 술어 p를 적용 후, 원래 배열의 부분집합을 돌려줍니다."></a><span class="caption">그림 3-6 필터는 주어진 배열 원소에 선별 기준을 나타내는 함수형 술어 p를 적용 후, 원래 배열의 부분집합을 돌려줍니다.</span></div><div style="clear:both;"></div><p>[코드 3-5]는 filter 함수 구현부입니다.<br><figure class="codeblock codeblock--tabbed"><figcaption><span>코드 3-5 filter 구현부</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">arr, predicate</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> idx = <span class="number">-1</span>,</span><br><span class="line">      len = arr.length,</span><br><span class="line">      result = [];</span><br><span class="line">  <span class="keyword">while</span>(++idx &lt; len) {</span><br><span class="line">    <span class="keyword">let</span> value = arr[idx];</span><br><span class="line">    <span class="keyword">if</span>(predicate(value, idx, <span class="keyword">this</span>)) {</span><br><span class="line">      result.push(value);</span><br><span class="line">    }</span><br><span class="line">  }    </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure></p><p>filter는 대상 배열과, 원소를 결과에 포함할지 결정하는 술어 함수 두 가지를 인수로 받습니다. 술어 함수 결과가 true인 원소는 남기고 그렇지 않은 원소는 내보냅니다. filter는 배열에서 오류 데이터를 제거하는 용도로 자주쓰입니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_(persons).filter(isValid).map(fullname);</span><br></pre></td></tr></table></figure></p><p>filter의 용도는 이뿐만이 아닙니다. Person 객체 컬렉션에서 1903년 출생자들만 추리고자 할 때, 조건문 대신 _.filter를 쓰면 코드가 훨씬 간결해집니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bornIn1903 = <span class="function"><span class="params">person</span> =&gt;</span> person.birthYear === <span class="number">1903</span>;</span><br><span class="line">_(persons).filter(bornIn1903).map(fullname).join(<span class="string">' and '</span>);</span><br><span class="line"><span class="comment">//-&gt; 'John von Neumann and Alonzo Church'</span></span><br></pre></td></tr></table></figure></p><p><strong>배열 축약</strong><br><div class="alert info no-icon"><p>map, filter는 어떤 배열을 받아 새 배열을 내는 고계함수로, 하스켈, 클로저 등 배부분의 함수형 프로그래밍 언어에 기본 내장되어 있습니다. 이들을 조합하는 대신 <strong>배열 축약(array comprehension) 또는 리스트 축약(list comprehension)</strong>이란 개념을 적용하는 방법도 있습니다. 배열 축약은 map, filter의 기능을 각각 for..of와 if 키워드를 이용하여 단축된 구문으로 캡슐화하는 함수형 장치입니다. 다음과 같은 형식입니다.<br>[for (x of 이터러블) if (조건) x]<br>이 책을 쓰는 현재 배열 축약은 ECMAScript 7 제안서에 포함되어 있습니다. 배열 축약을 활용하면 간결한 구문으로 새 배열을 조립할 수 있습니다. (그래서 전체 표현식을 []로 감쌉니다) 예를 들어 방금 전 코드는 다음과 같이 바꿔 써도 됩니다.<br>[for (p of people) if (p.birthYear === 1903) p.fullname].join(‘ and ‘);</p></div></p><p>지금까지 실펴본 것처럼, 확장성 좋고 강력한 함수를 이용해서 코딩하면 코드가 깔끔해질 뿐만 아니라 데이터를 더 잘 이해할 수 있습니다. 선언적 스타일은 개발자가 문제의 해법에 어떻게 도달해야 하는지 고민하기보다 <strong>애플리케이션이 어떤 결과를 내야 하는지에 전념하게 합니다.</strong> 따라서 애플리케이션을 더 깊이 있게 헤아리는 데 큰 도움이 됩니다.</p><h2 id="3-4-코드-헤아리기"><a href="#3-4-코드-헤아리기" class="headerlink" title="3.4 코드 헤아리기"></a>3.4 코드 헤아리기</h2><!-- 자바스크립트에서는 전역 이름공간을 공유하는 수천 줄의 코드를 한 페이지에 한 번에 로드할 수 있습니다. 최근 비즈니스 로직을 모듈 단위로 구분하는 문제에 사람들이 관심을 갖기 시작했지만, 아직도 그렇게 개발되지 않은 운영 시스템이 도처에 널려있습니다. --><p><strong><em>‘코드를 헤아린다(reason)’</em></strong> 는 건 무슨 뜻일까요? 1, 2장에서 필자는 프로그램의 일부만 들여다봐도 무슨 일을 하는 코드인지 멘털모델을 쉽게 구축할 수 있다는 의미로 이 표현을 사용했습니다. 여기서 멘털모델이란 전체 변수의 상태와 함수 출력 같은 동적인 부분뿐만 아니라, 설계 가독성 및 표현성 같은 정적인 측면까지 포괄하는 개념입니다. 두 가지 모두 중요합니다. 여러분은 이 책을 읽으며 불변성과 순수함수가 이러한 멘털 모델 구축을 더 용이하게 해준다는 사실을 깨닫게 될 것입니다.</p><p>앞서 필자는 고수준 연산을 서로 연결하여 프로그램을 구축하는 것이 중요하다고 강조했습니다. 명령형 프로그램은 흐름 자체가 함수형 프로그램과 근본적으로 다릅니다. 함수형 흐름은 프로그램 로직을 파헤치지 않아도 뭘 하는 프로그램인지 윤곽을 잡기 쉽기 때문에, 개발자는 코드뿐만 아니라 결과를 내기 위해 서로 다른 단계를 드나드는 흐름까지 더 깊이 헤아릴 수 있습니다.</p><h3 id="3-4-1-선언적-코드와-느긋한-함수-체인"><a href="#3-4-1-선언적-코드와-느긋한-함수-체인" class="headerlink" title="3.4.1 선언적 코드와 느긋한 함수 체인"></a>3.4.1 선언적 코드와 느긋한 함수 체인</h3><p>FP의 선언적 모델에 따르면, 프로그램이란 개별적인 순수함수들을 평가하는 과정이라 볼 수 있습니다. 그래서 필요 시 코드의 흐름성과 표현성을 높이기 위한 추상화 수단을 지원하며, 이렇게 함으로써 여러분이 개발하려는 애플리케이션의 실체를 명확하게 표현하는 <strong>온톨로지(ontology)</strong> 또는 <strong>어휘집(vocabulary)</strong>을 만들 수 있습니다. map, reduce, filter라는 구성 요소를 바탕으로 순수함수를 쌓아가면 자연스레 한눈에 봐도 흐름이 읽히는 코드가 완성됩니다.</p><p>이 정도 수준으로 추상화하면 비로소 기반 자료구조에 영향을 끼치지 않는 방향으로 연산을 바라볼 수 있습니다. 이론적으로 말해서 배열, 연결 리스트, 이진 트리 등 어떤 자료구조를 쓰더라도 프로그램 자체의 의미가 달라져선 안 됩니다. 그래서 FP는 자료구조보다 <strong>연산에 더 중점</strong>을 둡니다.</p><p>이름 리스트를 읽고 데이터를 정제 후, 중복은 제거하고 정렬하는 일련의 작업을 예로 들어봅시다. 명령형 버전으로 먼저 프로그램을 작성 후, 함수형으로 리펙터링 하겠습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'alonzo church'</span>, <span class="string">'Haskell curry'</span>, <span class="string">'stephen_kleene'</span>, <span class="string">'John Von Neumann'</span>, <span class="string">'stephen_kleene'</span>];</span><br></pre></td></tr></table></figure></p><p>[코드 3-6]은 명령형 프로그램입니다.<br><figure class="codeblock codeblock--tabbed"><figcaption><span>코드 3-6 배열을 순차적으로 연산(명령형)</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line">fot (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; names.length; i++) {   <span class="comment">//배열의 원소(이름)를 모두 순회합니다.</span></span><br><span class="line">  <span class="keyword">var</span> n = names[i];</span><br><span class="line">  <span class="keyword">if</span>(n !== <span class="literal">undefined</span> &amp;&amp; n !== <span class="literal">null</span>){   <span class="comment">//올바른 이름인지 조사합니다.</span></span><br><span class="line">    <span class="keyword">var</span> ns = n.replace(<span class="regexp">/_/</span>, <span class="string">' '</span>).split(<span class="string">' '</span>);   <span class="comment">//데이터 형식이 제각각일 수 있으니 정규화(정정) 단계가 필요합니다.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>; j &lt; ns.length; j++) {</span><br><span class="line">      <span class="keyword">var</span> p = ns[j];</span><br><span class="line">      p = p.charAt(<span class="number">0</span>).toUpperCase() + p.slice(<span class="number">1</span>);</span><br><span class="line">      ns[j] = p;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(result.indexOf(ns.join(<span class="string">' '</span>)) &lt; <span class="number">0</span>) {   <span class="comment">//result에 같은 이름이 있는지 보고 중복을 제거합니다.</span></span><br><span class="line">      result.push(ns.join(<span class="string">' '</span>))</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">result.sort();   <span class="comment">//배열을 정렬합니다.</span></span><br></pre></td></tr></tbody></table></figure></div></figure></p><p>결과는 제대로 나옵니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'Alonzo Church'</span>, <span class="string">'Haskell Curry'</span>, <span class="string">'John Von Neumann'</span>, <span class="string">'Stephen Kleene'</span>]</span><br></pre></td></tr></table></figure></p><p>명령형 코드의 단점은 특정 문제의 해결만을 목표한다는 점입니다. [코드 3-6]역시 함수형보다 훨씬 저수준에서 추상한 코드로서 한 가지 용도로 고정됩니다. 추상화 수준이 낮을수록 코드를 재사용할 기회는 줄어들고 에러 가능성과 코드 복잡성은 증가합니다.</p><p>반면, FP는 블랙박스 컴포넌트를 서로 연결만 해주고, 뒷일은 테스트까지 마친 검증된 API에게 모두 맡깁니다. 폭포수 떨어지듯 함수를 연달아 호출하는 모습이 눈에 더 잘 들어오지 않나요?<br><figure class="codeblock codeblock--tabbed"><figcaption><span>코드 3-7 배열을 순차적으로 연산(함수형)</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_.chain(names)                      <span class="comment">//함수 체인을 초기화합니다.</span></span><br><span class="line">    .filter(isValid)                <span class="comment">//잘못된 값은 제거합니다.</span></span><br><span class="line">    .map(<span class="function"><span class="params">s</span> =&gt;</span> s.replace(<span class="regexp">/_/</span>, <span class="string">' '</span>))  <span class="comment">//값을 정규화합니다.</span></span><br><span class="line">    .uniq()                         <span class="comment">//중복을 솎아냅니다.</span></span><br><span class="line">    .map(_.startCase)               <span class="comment">//대소문자를 맞춥니다.</span></span><br><span class="line">    .sort()</span><br><span class="line">    .value();</span><br><span class="line"><span class="comment">// -&gt; ['Alonzo Church', 'Haskell Curry', 'John Von Neumann', 'Stephen Kleene']</span></span><br></pre></td></tr></tbody></table></figure></div></figure></p><p>names 배열을 정확한 인덱스로 순회하는 등 버거운 일은 모두 _.filter와 _.map함수가 대행하므로 여러분은 그저 나머지 단계에 대한 프로그램 로직을 구현하면 됩니다. _.uniq로 중복 데이터를 집어내고, _.startCase로 각 단어의 첫자를 대문자로 바꾼 다음, 마지막에 알파벳 순으로 정렬을 합니다.</p><p>필자는 기왕이면 [코드 3-7] 같은 프로그램이 낫다고 봅니다. 여러분도 그런가요? 코딩 작업도 확연히 줄지만 단순 명료한 구조가 아주 매력적이네요.</p><p>Person 객체 배열에서 국가별 인구를 계산했던 [코드 3-4]로 돌아가 gatherStats 함수를 조금 보완합시다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gatherStats = <span class="function"><span class="keyword">function</span>(<span class="params">stat, country</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!isValid(stat[country])) &#123;</span><br><span class="line">    stat[country]= &#123;<span class="string">'name'</span> : country, <span class="string">'count'</span>: <span class="number">0</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  stat[country].count++;</span><br><span class="line">  <span class="keyword">return</span> stat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이제 다음과 같은 구조를 지닌 객체가 반환되겠죠,<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'US'</span> : &#123;<span class="string">'name'</span>: <span class="string">'US'</span>, <span class="attr">count</span>: <span class="number">2</span>&#125;,</span><br><span class="line">  <span class="string">'Greece'</span> : &#123;<span class="string">'name'</span>: <span class="string">'Greece'</span>, <span class="attr">count</span>: <span class="number">1</span>&#125;,</span><br><span class="line">  <span class="string">'Hungary'</span> : &#123;<span class="string">'name'</span>: <span class="string">'Hungary'</span>, <span class="attr">count</span>: <span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 객체에서 국가별 데이터는 반드시 하나뿐입니다. 재미삼아 Person 배열에 데이터를 몇 개 더 넣어볼까요?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p5 = <span class="keyword">new</span> Person(<span class="string">'David'</span>, <span class="string">'Hilbert'</span>, <span class="string">'555-55-5555'</span>);</span><br><span class="line">p5.address = <span class="keyword">new</span> Address(<span class="string">'Germany'</span>);</span><br><span class="line">p5.birthYear = <span class="number">1903</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p6 = <span class="keyword">new</span> Person(<span class="string">'Alan'</span>, <span class="string">'Turing'</span>, <span class="string">'666-66-6666'</span>);</span><br><span class="line">p6.address = <span class="keyword">new</span> Address(<span class="string">'England'</span>);</span><br><span class="line">p6.birthYear = <span class="number">1912</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p7 = <span class="keyword">new</span> Person(<span class="string">'Stephen'</span>, <span class="string">'Kleene'</span>, <span class="string">'777-77-7777'</span>);</span><br><span class="line">p7.address = <span class="keyword">new</span> Address(<span class="string">'US'</span>);</span><br><span class="line">p7.birthYear = <span class="number">1909</span>;</span><br></pre></td></tr></table></figure></p><p>다음은 인구가 가장 많은 국가를 반환하는 프로그램입니다. 이번에도 여러 함수형 장치들을 _.chain() 함수로 연결하겠습니다.<br><figure class="codeblock codeblock--tabbed"><figcaption><span>코드 3-8 로대시JS로 만든 느긋한 함수 체인</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.chain(persons)                      <span class="comment">//느긋한 함수체인을 만들어 주어진 배열을 처리합니다.</span></span><br><span class="line">   .filter(isValid)                </span><br><span class="line">   .map(_.property(<span class="string">'address.country'</span>))  <span class="comment">//Person 객체의 address.country 속성을 _.property로 얻습니다. _.property는 람다JS의 R.view()와 거의 같은 로대시JS 함수입니다.</span></span><br><span class="line">   .reduce(gatherStats, {})        </span><br><span class="line">   .values()</span><br><span class="line">   .sortBy(<span class="string">'count'</span>)</span><br><span class="line">   .reverse()</span><br><span class="line">   .first()</span><br><span class="line">   .value()    <span class="comment">//체인에 연결된 함수를 모두 실행합니다.</span></span><br><span class="line">   .name;  <span class="comment">//'US'</span></span><br></pre></td></tr></tbody></table></figure></div></figure></p><p>_.chain 함수는 주어진 입력을 출력으로 변환하는 연산들을 연결함으로써 입력 객체의 상태를 확장합니다. _(…) 객체로 단축 표기한 구문과 달리, 이 함수는 임의의 함수를 명시적으로 체이닝 가능한 함수로 만듭니다. </p><p>_.chain을 쓰면 복잡한 프로그램을 느긋하게 작동시키는 장점도 있습니다. 제일 끝에서 value() 함수를 호출하기 전에는 아무것도 실행되지 않으니까요. 결과값이 필요 없는 함수는 실행을 건너뛸 수 있어서 애플리케이션 성능에 엄청난 영향을 미칩니다. [그림 3-7]은 이 프로그램의 제어 흐름을 나타낸 것 입니다.</p><div class="figure center" style="width:100%;"><a class="fancybox" href="picture_3-7.png" title="로대시JS 함수를 체이닝하여 구성한 프로그램 제어구조. Person 객체 배열은 각 연산을 차례로 지나면서 처리되고 결국 하나의 값으로 변환됩니다." data-caption="로대시JS 함수를 체이닝하여 구성한 프로그램 제어구조. Person 객체 배열은 각 연산을 차례로 지나면서 처리되고 결국 하나의 값으로 변환됩니다." data-fancybox="FunctionalPrograming_chapter3"><img class="fig-img" src="picture_3-7.png" style="width:100%;height:100%;" alt="로대시JS 함수를 체이닝하여 구성한 프로그램 제어구조. Person 객체 배열은 각 연산을 차례로 지나면서 처리되고 결국 하나의 값으로 변환됩니다."></a><span class="caption">로대시JS 함수를 체이닝하여 구성한 프로그램 제어구조. Person 객체 배열은 각 연산을 차례로 지나면서 처리되고 결국 하나의 값으로 변환됩니다.</span></div><div style="clear:both;"></div><p>이제 함수형 프로그램이 왜 우월한지 감이 오나요? 명령형으로 작성했다면 어떤 코드가 됐을지 한번 상상해보세요. [코드 3-8]이 부드럽게 작동하는 건 FP의 근본 원리인, 부수효과 없는 순수함수 덕분입니다. 체인에 속한 각 함수는 이전 단계의 함수가 제공한 새 배열에 자신의 불변 연산을 적용합니다. _.chain()으로 시작하는 이런 로대시JS의 패턴은 거의 모든 요구를 충족하는 맥가이버 칼을 제공합니다. 이런 방식은 함수형 프로그래밍의 독특한 <strong>무인수(point-free)</strong> 프로그래밍 스타일로 이어지는데요, 자세한 얘기는 다음 장 도입부에서 소개합니다.</p><h3 id="3-4-2-유사-SQL-데이터-데이터로서의-함수"><a href="#3-4-2-유사-SQL-데이터-데이터로서의-함수" class="headerlink" title="3.4.2 유사 SQL 데이터: 데이터로서의 함수"></a>3.4.2 유사 SQL 데이터: 데이터로서의 함수</h3><p>지금까지 map, reduce, filter, groupBy, sortBy, uniq 등의 함수를 살펴봤는데요, 이름을 잘 보면 그 어휘만으로도 함수가 데이터에 하는 일이 무엇인지 어렵잖게 추론할 수 있습니다. 그런데 관점을 조금만 틀어보면 이 함수들이 SQL 구문을 쏙 빼 닮았다는 사실을 알 수 있습니다. 이는 우연이 아닙니다.</p><p>개발자 대부분 SQL에 익숙한 편이라 쿼리만 봐도 데이터에 무슨 작업을 하는지 압니다. 예를 들어 Person 객체 컬렉션은 [표 3-1]처럼 나타낼 수 있습니다.</p><p><strong>표 3-1 테이블로 표현한 Person 리스트</strong></p><table><thead><tr><th>ID</th><th>이름</th><th>성</th><th>국적</th><th>생년</th></tr></thead><tbody><tr><td>0</td><td>Haskell</td><td>Curry</td><td>US</td><td>1900</td></tr><tr><td>1</td><td>Barkley</td><td>Rosser</td><td>Greece</td><td>1907</td></tr><tr><td>2</td><td>John</td><td>Von Neumann</td><td>Hungary</td><td>1903</td></tr><tr><td>3</td><td>Alonzo</td><td>Church</td><td>US</td><td>1903</td></tr><tr><td>4</td><td>David</td><td>Hilbert</td><td>Germany</td><td>1862</td></tr><tr><td>5</td><td>Alan</td><td>Turing</td><td>England</td><td>1912</td></tr><tr><td>6</td><td>Stephen</td><td>Kleene</td><td>US</td><td>1909</td></tr></tbody></table><p>결국 쿼리 언어를 구사하듯 개발하는 것과 함수형 프로그래밍에서 배열에 연산을 적용하는 것은 일맥상통합니다. 함수형 프로그램은 흔히 사용되는 어휘집이나 대수학 개념을 활용해서 데이터 자체의 성격과 구조 체계를 더 깊이 추론할 수 있게 도움을 줍니다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.firstname <span class="keyword">FROM</span> Person p</span><br><span class="line"><span class="keyword">WHERE</span> p.birthYear &gt; <span class="number">1903</span> <span class="keyword">and</span> p.country <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="string">'US'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> p.firstname</span><br></pre></td></tr></table></figure></p><p>위 쿼리는 실행 결과가 어떤 데이터가 나올지 불 보듯 훤합니다. 자바스크립트 버전의 프로그램으로 전환하기 전에 몇 가지 함수 별칭을 세팅해서 요점을 분명히 하겠습니다. 로대시JS가 지원하는 <strong>믹스인(mixin)</strong>(섞어 넣기) 기능을 응용하면, 핵심 라이브러리에 함수를 추가하여 확장한 후 마치 원래 있던 함수처럼 체이닝 할 수 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_.mixin(&#123;<span class="string">'select'</span> : _.map,</span><br><span class="line">         <span class="string">'from'</span> : _.chain,</span><br><span class="line">         <span class="string">'where'</span> : _.filter,</span><br><span class="line">         <span class="string">'sortBy'</span> : _.sortByOrder&#125;);</span><br></pre></td></tr></table></figure><p>이렇게 만든 믹스인 객체는 다음 프로그램처럼 적용 할 수 있습니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>코드 3-9 자바스크립트를 SQL 비슷하게 작성하기</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.from(persons)</span><br><span class="line"> .where(<span class="function"><span class="params">p</span> =&gt;</span> birthYear &gt; <span class="number">1900</span> &amp;&amp; p.address.country !== <span class="string">'US'</span>)</span><br><span class="line"> .sortBy([<span class="string">'firstname'</span>])</span><br><span class="line"> .select(<span class="function"><span class="params">p</span> =&gt;</span> p.firstname)</span><br><span class="line"> .value();</span><br></pre></td></tr></tbody></table></figure></div></figure><p>SQL 키워드와 동일한 별칭으로 기능을 매핑해서 함수형 코드를 쿼리 언어와 최대한 유사하게 작성해봤습니다.</p><div class="alert info no-icon"><p>믹스인은(예제의 SQL 명령어처럼) 특정 형식과 연관된 함수를 부분적으로 추상한 객체입니다. 그래서 그 자체로 쓰이기 보단 다른 객체의 로직을 확장하는 용도로 활용합니다.(다른 프로그래밍 언어의 <strong>트레이트(trait)</strong>와 비슷합니다) 타깃 객체는 믹스인의 모든 기능을 빌려 쓰게 됩니다.</p><p>믹스인은 OOP 세계에서 다중 상속(multiple inheritance)을 지원하지 않는 언어(자바스크립트도 그중 하납니다)에서 다중 상속을 모방하거나, 상속 등의 우회책을 쓰지 않아도 코드를 재사용할 수 있게 합니다. 이 책에서 다루지는 않지만 믹스인은 잘 활용하면 아주 강력한 수단이니, 더 자세히 알고 싶다면 앵거스 크롤이 쓴 글 (<a href="http://mng.bz/15Zj" target="_blank" rel="noopener">http://mng.bz/15Zj</a>) 을 읽어보세요</p></div><p>자. 이제 함수형 프로그래밍이 명령형 코드 위에 강력한 추상화를 제공한다는 믿음이 생겼으리라 봅니다. 데이터를 처리하고 파싱하는 데 쿼리 언어보다 더 좋은 방법이 있을까요? 자바스크립트 코드도 SQL처럼 데이터를 함수 형태로 모형화 할 수 있는데, 이를 <strong>데이터로서의 함수(functions as data)</strong>라는 개념으로 부르기도 합니다. 선언적으로 어떤 데이터가 출력되어야 할지 서술할 뿐 그 출력을 <strong>어떻게</strong> 얻는지는 논하지 않지요. 필자는 이번 장에서 루프문을 전혀 쓸 필요가 없었고, 앞으로도 루프를 쓰지 않으려고 합니다. 고수준의 추상화로 루프를 대체할 수 있으니까요.</p><p>재귀 역시 루프를 대체할 때 많이 쓰는 기법입니다. 천성이 자기 반복적(self-similar)인 문제에 대해 반복 자체를 재귀로 추상하여 푸는 방법이지요. 이런 유형의 문제는 순차적 함수 체인만으로는 해결하기 어렵고 비효율적입니다. 하지만 재귀는 일반 루프로 수행하는 버거운 작업을 언어 자체의 런타임에 맡김으로써 독자적인 방식으로 데이터를 처리합니다.</p><h2 id="3-5-재귀적-사고방식"><a href="#3-5-재귀적-사고방식" class="headerlink" title="3.5 재귀적 사고방식"></a>3.5 재귀적 사고방식</h2><p>좀처럼 머릿속에 해법이 떠오르지 않는 어렵고 복잡한 문제들이 있습니다. 이럴 땐 바로 문제를 분해할 방법을 찾아야 합니다. 전체 문제를 더 작은 분신들로 쪼갤 수 있다면 작은 문제들을 하나씩 풀면서 전체 문제도 풀 수 있을 것 입니다.</p><p>자바스크립트에서 XML 파일, HTML 문서, 그래프 등을 파싱할 때 재귀를 다양하게 활용합니다. 이 절에서는 재귀가 무엇인지, 그리고 재귀적으로 생각하는 방법을 예제와 함께 설명하고, 재귀를 이용해 몇몇 자료구조를 파싱하는 예제를 함께 살펴보겠습니다.</p><h3 id="3-5-1-재귀란"><a href="#3-5-1-재귀란" class="headerlink" title="3.5.1 재귀란?"></a>3.5.1 재귀란?</h3><p><strong>재귀(recusion)</strong>는 주어진 문제를 자기 반복적인 문제들로 잘게 분해한 다음, 이들을 다시 조합해 원래 문제의 정답을 찾는기법입니다. 재귀 함수의 주된 구성 요소는 다음과 같습니다.</p><blockquote><ul><li>기저 케이스(base case, 종료 조건:terminating condition이라고도 합니다)</li><li>재귀 케이스(recursive case) </li></ul></blockquote><p>기저 케이스는 재귀 함수가 구체적인 결과값을 바로 계산할 수 있는 입력 집합입니다. 재귀 케이스는 함수가 자신을 호출할 때 전달한 입력 집합(최초 입력 집합보다 점점 작아집니다)을 처리합니다. 입력 집합이 점점 작아지지 않으면 재귀가 무한 반복되며 결국 프로그램이 뻗겠죠. 함수가 반복될수록 입력 집합은 무조건 작아지며, 제일 마지막에 기저 케이스로 빠지면 하나씩 값으로 귀결됩니다.</p><!-- 2장에서도 중첩된 객체를 재귀로 탐색하면서 전체 자료구조를 깊이 동결했습니다. 탐색한 객체가 기본형이거나 이미 동결한 상태면 기저 케이스로 빼내고, 그 외에는 계속 객체 구조를 훑으며 미동결 객체를 재귀적으로 탐색합니다. 단계마다 하는 일이 정확히 일치하므로 재귀로 풀기 적합한 문제였습니다. 그런데 재귀적 사고가 그리 녹록한 건 아닙니다. --><h3 id="3-5-2-재귀적으로-생각하기"><a href="#3-5-2-재귀적으로-생각하기" class="headerlink" title="3.5.2 재귀적으로 생각하기"></a>3.5.2 재귀적으로 생각하기</h3><p>재귀적 사고란, 자기 자신 또는 그 자신을 변형한 버전을 생각하는 겁니다. 재귀적 객체는 스스로를 정의합니다. 가령 트리 구조에서 가지(branch)를 합성한다고 합시다. 어떤 가지는 다른 가지처럼 잎(leaf)이 붙어 있고, 이 잎에는 또다른 잎과 가지가 주렁주렁 달려 있겟죠. 이런 프로세스가 끝없이 이어지다가 어떤 외부적인 한정 요소(트리의 전체 크기)에 이르면 멈출 것입니다.</p><p>자, 그럼 준비운동 겸 숫자 배열의 원소를 모두 더하는 간단한 예제를 봅시다. 우선 명령형 버전으로 구현한 다음 점점 함수형으로 고쳐보겠습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> acc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">  acc += nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>그리고 중간에 합계를 어딘가 보관하기 위해 누산치가 필요하다는 강박증에 사로잡혀 있겠죠. 하지만 수동 루프가 정말 필요할까요? 이미 여러분 손에는 당장 꺼내 쓸 수 있는 함수형 무기 (_.reduce)가 있습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_(nums).reduce(<span class="function">(<span class="params">acc, current</span>) =&gt;</span> acc + current, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>수동 반복 코드를 프레임워크에 밀어 넣어 애플리케이션 코드로부터 추상하는 방법도 있지만, 반복하는 작업 자체를 일임할 수 있다면 더 좋겠지요? _.reduce 함수를 쓰면 루프는 물론 리스트 크기조차 신경 쓸 필요가 없습니다. 첫 번째 원소를 나머지 원소들과 순차적으로 더해가며 결과값을 계산하는 재귀적 사고방식을 적용하는 셈이죠. 이 사고방식을 확장하면 결국 다음과 같이 <strong>수평사고(lateral thinking)</strong>라고 불리는 일련의 연산을 수행하는 과정으로 덧셈을 바라보게 됩니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] = <span class="number">1</span> + sum[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">                       = <span class="number">1</span> + <span class="number">2</span> + sum[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">                       = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + sum[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure></p><p>재귀의 반복은 동전의 앞/뒷면입니다. 재귀는 변이가 없으므로, 더 강력하고 우수하며 표현적인 방식으로 반복을 대체할 수 있습니다. 사실상 순수 함수형 언어는 모든 루프를 재귀로 수행하기 때문에 do, for, while 같은 기본 루프 체계조차 없으며, 재귀를 적용한 코드가 더 이해하기 쉽습니다. 점점 줄어드는 입력 집합에 똑같은 작업을 여러 번 반복한다는 전헤하에 작동하기 때문입니다. [코드 3-10]의 재귀 코드는 로대시JS의 _.first, _.rest 함수로 각각 배열 첫 번째 원소와 그 나머지 원소들에 접근합니다.<br><figure class="codeblock codeblock--tabbed"><figcaption><span>코드 3-10 재귀적 덧셈</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span>(_.isEmpty(arr)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> _.first(arr) + sum(_.rest(arr));    <span class="comment">//재귀 케이스 : _.first와 _.rest로 입력을 점점 줄여가며 자신을 호출합니다.</span></span><br><span class="line">}</span><br><span class="line">sum([]); <span class="comment">//-&gt; 0</span></span><br><span class="line">sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]); <span class="comment">//-&gt; 45</span></span><br></pre></td></tr></tbody></table></figure></div></figure><br>더하려는 배열이 빈 배열일 경우 기저 케이스로서 이때는 당연히 0을 반환합니다. 이외에 원소가 포함된 배열은 첫 번째 원소를 추출 후 두 번째 이후 원소들과 계속 재귀적으로 더합니다. 이때 내부적으로 재귀 호출 스택이 겹겹이 쌓입니다. 알고리즘이 종료 조건에 이르면 쌓인 스택이 런타임에 의해 즉시 풀리면서 모두 실행되고 이 과정에서 실제 덧셈이 이루어 집니다. 바로 이런식으로 재귀를 이용해 언어 런타임에 루프를 맡기는 것입니다. 다음은 이러한 덧셈 알고리즘을 단계별로 나누어 표시한 것입니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + sum[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + sum[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + sum[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] </span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + sum[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] </span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + sum[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] </span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + sum[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] </span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> + sum[<span class="number">8</span>,<span class="number">9</span>] </span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> + <span class="number">8</span> + sum[<span class="number">9</span>] </span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> + <span class="number">8</span> + <span class="number">9</span> + sum[]</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> + <span class="number">8</span> + <span class="number">9</span> + <span class="number">0</span> <span class="comment">// -&gt; 여기서 정지, 이제 스텍이 풀립니다.</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> + <span class="number">8</span> + <span class="number">9</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> + <span class="number">17</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">24</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">30</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">35</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">39</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">42</span></span><br><span class="line"><span class="number">1</span> + <span class="number">44</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure></p><p>재귀와 수동 반복, 성능은 어떨까요? 지난 세월 동안 컴파일러는 아주 영리하게 루프를 최적화 할 수 있도록 진화했습니다. ES6 부터는 꼬리 호출 최적화(tail-call optimization)까지 추가되어 사실상 재귀와 수동 반복의 성능 차이는 미미해졌지요. 다음은 sum 함수를 조금 다른 방법으로 구현한 코드입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr, acc = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(_.isEmpty(arr)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum(_.rest(arr), acc + _.first(arr));  <span class="comment">//꼬리 위치에서 재귀 호출</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 본체의 가장 마지막 단계, 즉 꼬리 위치(tail position)에서 재귀 호출을 합니다. 이렇게 하면 어떤 이점이 있는지는 7장에서 함수형 최적화를 이야기하며 다시 살펴보겠습니다.</p><h3 id="3-5-3-재귀적으로-정의한-자료구조"><a href="#3-5-3-재귀적으로-정의한-자료구조" class="headerlink" title="3.5.3 재귀적으로 정의한 자료구조"></a>3.5.3 재귀적으로 정의한 자료구조</h3><p>지금까지 Person 객체의 샘플 데이터로 입력한 이름들이 대체 누굴까 궁금하게 생각한 독자도 있을 겁니다. 1900년대는 함수형 프로그래밍의 원조를 이룬 수학 분파(람다 대수학, 범주론등)의 활동이 왕성했었죠.</p><p>이 시기에 출간된 자료는 대부분 알론조 처치(Alonzo Church) 교수가 이끄는 몇몇 대학 교수들이 집대성한 식견과 정리에 근거합니다. 바클리 로서(Barkley Rosser), 엘런 튜링(Alan Turing), 스티븐 클리니(Stephen Kleene)같은 수학자들이 바로 처치 교수의 박사 학위 지도를 받은 학생들이었죠. [그림 3-8]은 이 사제 관계를 그래프로 나타낸 것입니다.<br><div class="figure center" style="width:100%;"><a class="fancybox" href="picture_3-8.png" title="그림 3-8 함수형 프로그래밍에 지대한 공헌을 한 수학자들. 트리에서 부모 -> 자식 방향으로 연결된 화살표가 '~의 학생'이라는 관계를 뜻합니다." data-caption="그림 3-8 함수형 프로그래밍에 지대한 공헌을 한 수학자들. 트리에서 부모 -> 자식 방향으로 연결된 화살표가 '~의 학생'이라는 관계를 뜻합니다." data-fancybox="FunctionalPrograming_chapter3"><img class="fig-img" src="picture_3-8.png" style="width:100%;height:100%;" alt="그림 3-8 함수형 프로그래밍에 지대한 공헌을 한 수학자들. 트리에서 부모 -> 자식 방향으로 연결된 화살표가 '~의 학생'이라는 관계를 뜻합니다."></a><span class="caption">그림 3-8 함수형 프로그래밍에 지대한 공헌을 한 수학자들. 트리에서 부모 -> 자식 방향으로 연결된 화살표가 '~의 학생'이라는 관계를 뜻합니다.</span></div><div style="clear:both;"></div></p><p>트리는 XML 문서, 파일 시스템, 분류학, 범주, 메뉴 위젯, 패시 내비게이션, 소셜 그래프 등 다양한 분야에 쓰이는 아주 일반적인 자료구조로서 처리 방법을 잘 알아둘 필요가 있습니다. [그림 3-8]을 잘 보면 여러 노드(node)가 사제 관계를 나타내는 간선(edge: 화살표)으로 연결되어 있습니다. 배열처럼 평탄한 자료구조를 파싱할 때 쓰는 함수형 기법은 이런 트리 구조의 데이터에는 적절하지 않습니다. 자바스크립트 언어 자체로 내장 트리 객체를 지원하지는 않으므로 노드 기반의 단순한 자료구조를 만들어야 합니다. 노드는 값을 지닌 객체로 자신의 부모와 자식 배열을 레퍼런스로 참조합니다. [그림 3-8]에서 Rosser는 Church를 부모 노드로, Mendelson과 Sacks는 자식 노드로 가리킵니다. Church처럼 부모가 없는 노드가 루트입니다. 다음은 Node 형을 정의한 코드입니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>코드 3-11 Node 객체</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>(val) {</span><br><span class="line">    <span class="keyword">this</span>._val = val;</span><br><span class="line">    <span class="keyword">this</span>._parent = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>._children = [];</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  isRoot() {</span><br><span class="line">    <span class="keyword">return</span> isValid(<span class="keyword">this</span>._parent);    <span class="comment">//앞에서 만들었던 함수입니다.</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  get children() {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._children</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  hasChildren() {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._children.length &gt; <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  get value() {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._val;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  set value(val) {</span><br><span class="line">    <span class="keyword">this</span>._val = val;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  append(child) {</span><br><span class="line">    child._parent = <span class="keyword">this</span>;    <span class="comment">//부모 노드를 세팅합니다.</span></span><br><span class="line">    <span class="keyword">this</span>._children.push(child);    <span class="comment">//자식 리스트에 자식 노드를 추가합니다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;   <span class="comment">//동일한 노드를 반환합니다(이렇게 해야 메서드를 흘릴 때 편합니다)</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  toString() {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Node (val: <span class="subst">${<span class="keyword">this</span>._val}</span>, children: <span class="subst">${<span class="keyword">this</span>._children.length}</span>)`</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>노드는 이렇게 생성합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> church = <span class="keyword">new</span> Node(<span class="keyword">new</span> Person(<span class="string">'Alonzo'</span>, <span class="string">'Church'</span>, <span class="string">'111-11-1111'</span>));   <span class="comment">//이를 트리에 있는 모든 노드마다 반복합니다.</span></span><br></pre></td></tr></table></figure><p><strong>트리(tree)</strong>는 루트 노드가 포함된 재귀적인 자료구조 입니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(root) &#123;</span><br><span class="line">    <span class="keyword">this</span>._root = root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> map(node, fn, tree = <span class="literal">null</span>) &#123;   <span class="comment">//이 메서드보다 더 많이 쓰이는 Array.prototype.map과 혼동하지 않게 정적 메서드로 합니다. 정적 메서드는 사실상 독립형 함수로 쓸 수 있습니다.</span></span><br><span class="line">    node.value = fn(node.value);    <span class="comment">//이터레이터 함수를 실행하여 트리의 노드값을 업데이트 합니다.</span></span><br><span class="line">    <span class="keyword">if</span>(tree === <span class="literal">null</span>) &#123;</span><br><span class="line">      tree = <span class="keyword">new</span> Tree(node);    <span class="comment">//Array.prototype.map과 비슷합니다. 새로운 트리를 만듭니다.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node.hasChildren()) &#123;    <span class="comment">//자식이 없는 노드는 계속할 필요가 없습니다(기저 케이스)</span></span><br><span class="line">      _.map(node.children, <span class="function"><span class="keyword">function</span>(<span class="params">child</span>) </span>&#123;    <span class="comment">//각 자식 노드에 주어진 함수를 실행합니다.</span></span><br><span class="line">        Tree.map(child, fn, tree)   <span class="comment">//각 자식 노드를 재귀 호출 합니다.</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get root() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>노드의 메인 로직은 append 메서드에 있습니다. 한 노드에 자식을 덧붙일 때 그 자식 노드의 부모 레퍼런스가 이 노드를 가리키게 하고 이 자식 노드를 자식 리스트에 추가합니다. 다음과 같은 식으로 루트부터 시작해 다른 자식 노드들과 연결하면 트리가 완성됩니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">church.append(rosser).append(turing).append(kleene);</span><br><span class="line">kleene.append(nelson).append(constable);</span><br><span class="line">rosser.append(mendelson).append(sacks);</span><br><span class="line">turing.append(gandy)</span><br></pre></td></tr></table></figure></p><p>각 노드는 Person 객체를 감쌉니다. 재귀 알고리즘은 루트서부터 모든 자식 노드를 타고 내려가면서 전체 트리를 전위 순회(preorder traversal) 합니다. 자기 반복적인 재귀 특성 때문에 순회를 루트에서 시작하든, 임의의 노드에서 시작하든 똑같습니다. 그래서 Array.prototype.map과 하는 일이 비슷한 고계함수 Tree.map을 쓰는 건데요, 이 함수는 각 노드 값을 평가할 함수를 받습니다. 보다시피 이 데이터를 모형화한 자료구조(여기선 트리)와 무관하게 이 함수의 의미는 변함 없습니다. 사실상 어떤 자료형이라도 그 구조를 유지한 채 매핑할 수 있지요. 이렇게 구조를 유지한 상태에서 함수를 자료형에 매핑하는 함수 개념을 5장에서 더 자세히 이야기 할 것입니다.</p><p>루트 노드에서 출발한 전위 순회는 다음 과정을 거칩니다.</p><blockquote><ol><li>루트원소의 데이터를 표시합니다.</li><li>전위 함수를 재귀 호출하여 왼쪽 하위 트리를 탐색합니다.</li><li>같은 방법으로 오른쪽 하위 트리를 탐색합니다.</li></ol></blockquote><p>[그림 3-9]는 이 알고리즘이 지나가는 경로입니다.<br><div class="figure center" style="width:100%;"><a class="fancybox" href="picture_3-9.png" title="그림 3-9 재귀적 전위 순회경로. 루트에서 출발해 왼쪽에서 오른쪽 방향으로 자식 노드를 훑고 내려갑니다." data-caption="그림 3-9 재귀적 전위 순회경로. 루트에서 출발해 왼쪽에서 오른쪽 방향으로 자식 노드를 훑고 내려갑니다." data-fancybox="FunctionalPrograming_chapter3"><img class="fig-img" src="picture_3-9.png" style="width:100%;height:100%;" alt="그림 3-9 재귀적 전위 순회경로. 루트에서 출발해 왼쪽에서 오른쪽 방향으로 자식 노드를 훑고 내려갑니다."></a><span class="caption">그림 3-9 재귀적 전위 순회경로. 루트에서 출발해 왼쪽에서 오른쪽 방향으로 자식 노드를 훑고 내려갑니다.</span></div><div style="clear:both;"></div></p><p>Tree.map 함수는 루트노드(기본적으로, 트리의 시작 지점) 및 각 노드 값을 변환하는 이터레이터 함수를 필수로 밭습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tree.map(church, p =&gt; p.fullname);</span><br></pre></td></tr></table></figure></p><p>트리를 전위 순회하면서 해당 함수를 각 노드에 실행하면 다음 결과가 나옵니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Alonzo Church'</span>, <span class="string">'Barkley Rosser'</span>, <span class="string">'Ellot Mendelson'</span>, <span class="string">'Gerald Sacks'</span>, <span class="string">'Alan Turing'</span>, <span class="string">'Robin Gandy'</span>, <span class="string">'Stephen Kleene'</span>, <span class="string">'Nels Nelson'</span>, <span class="string">'Robert Constable'</span>,</span><br></pre></td></tr></table></figure></p><p>변이 및 부수효과 없는 자료형을 다룰 때 데이터 자체를 캡술화하여 데이터에 접근하는 방법을 통제하는 것이 함수형 프로그래밍의 관건입니다. 자료구조 파싱은 소프트웨어에서 가장 기본적인 작업이자, 함수형 프로그래밍의 주특기이기도 합니다. 이 장에서는 함수형 확장 라이브러리 로대시JS와 이의 바탕이 되는 자바스크립트 함수형개발 스타일에 관하여 자세히 알아보았습니다. 함수형 프로그래밍은 원하는 결과를 얻기 위한 비즈니스 로직이 담겨 있는 고수준의 연산을 일련의 단계들로 체이닝하는, 간결한 흐름 중심의 모델을 선호합니다.</p><p>이처럼 흐름 중심으로 코딩하면 재사용성, 모듈화 측면에서도 당연히 유익한데요, 이 장에서 필자는 아주 대략적으로만 살펴보았습니다. 4장에서는 흐름 중심의 프로그래밍 사상을 한 수준 더 발전시켜 진짜 함수 파이프라인을 구축하는 문제를 집중적으로 논합니다.</p><h3 id="3-6-마치며"><a href="#3-6-마치며" class="headerlink" title="3.6 마치며"></a>3.6 마치며</h3><blockquote><ul><li>고계함수 map, reduce, filter를 쓰면 코드를 확장할 수 있습니다.</li><li>로대시JS는 데이터 흐름과 변환 과정이 명확히 구획된 제어 체인을 통해 데이터 처리 및 프로그램 작성을 도모합니다.</li><li>함수형 프로그래밍의 선언적 스타일로 개발하면 코드를 헤아리기 쉽습니다.</li><li>고수준의 추상화를 SQL 어휘로 매핑하면 더 심도있게 데이터를 이해할 수 있습니다.</li><li>재귀는 자기 반복적 문제를 해결하는 데 쓰이며, 정의된 자료구조를 재귀적으로 파싱해야 합니다.</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;함수형 자바스크립트 - 스터디 정리 Chapter 3 (자료구조는 적게, 일은 더 많이)&lt;br&gt;
    
    </summary>
    
      <category term="FunctionalProgramming" scheme="http://ksw1652.github.io/categories/FunctionalProgramming/"/>
    
    
      <category term="함수형자바스크립트" scheme="http://ksw1652.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="FunctionalProgrammingInJavascript" scheme="http://ksw1652.github.io/tags/FunctionalProgrammingInJavascript/"/>
    
  </entry>
  
  <entry>
    <title>함수형 자바스크립트 스터디 내용정리 (Chapter1)</title>
    <link href="http://ksw1652.github.io/2019/02/11/%ED%95%A8%EC%88%98%ED%98%95%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Javascript-Chapter1/"/>
    <id>http://ksw1652.github.io/2019/02/11/함수형프로그래밍-Javascript-Chapter1/</id>
    <published>2019-02-11T07:38:27.000Z</published>
    <updated>2019-03-15T08:37:10.784Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><p><em>본 포스트의 내용은 <strong>FUNCTIONAL PROGRAMMING IN JAVASCRIPT (함수형 자바스크립트)</strong> 교재의 스터디 내용을 기반으로 작성하였습니다</em></p><h3 id="이-장의-내용"><a href="#이-장의-내용" class="headerlink" title="이 장의 내용"></a>이 장의 내용</h3><blockquote><ul><li>함수형 사고방식</li><li>함수형 프로그래밍의 정의와 필요성</li><li>불변성, 순수함수 원리</li><li>함수형 프로그래밍 기법 및 그것이 설계 전반에 미치는 영향</li></ul></blockquote><p>근래의 웹 플랫폼은 굉장히 빠른 속도로 발전 중이고 브라우저 역시 꾸준히 진화하고 있지만, 최종 사용자들의 요건이 웹 어플리케이션 설계 방식에 지대한 영향을 미칩니다.</p><p>오늘날의 웹은 수년 전 웹과는 근본적으로 다릅니다. 과거에 기술적으로 거의 불가능했던 일들이 지금은 얼마든지 구현가능 합니다.</p><p>최근 유행하기 시작한 <strong>리액티브 프로그래밍</strong> 은 데이터 흐름(data flow)과 변경 전파(Propagation of change)에 초점을 둡니다. 이 개념은 자바스크립트 비동기 또는 이벤트 중심(event-driven)코드를 다룰 때에도 아주 중요합니다.</p><p>이러한 흐름에 맞추어 반드시 자문해봐 할 애플리케이션의 설계 요소는</p><blockquote><p><strong>확장성</strong>: 추가 기능을 지원하기 위해 계속 코드를 리팩토링 해야 하는가?<br><strong>모듈화 용이성</strong>: 파일 하나를 고치면 다른 파일도 영향을 받는가?<br><strong>테스트성</strong> : 함수를 단위 테스트하기 어려운가?<br><strong>헤아리기 쉬움</strong>: 체계도 없고 따라가기 어려운 코드인가</p></blockquote><p>이 중 한가지라도 “예” 또는 “잘 모르겠는데요”라고 대답했다면 이 책은 여러분의 생산성을 높여주는 적합한 안내서가 될것입니다.</p><h2 id="1-1-함수형-프로그래밍은-과연-유용한가"><a href="#1-1-함수형-프로그래밍은-과연-유용한가" class="headerlink" title="1.1 함수형 프로그래밍은 과연 유용한가?"></a>1.1 함수형 프로그래밍은 과연 유용한가?</h2><p>자바스크립트의 맥락에서 보면 FP(Functional Programming)사고방식은 자바스크립트만의 매우 표현적인 특성을 가다듬어, 깔끔하면서도 모듈적인, 테스트하기 좋은 간결한 코드들 작성하는데 도움이 됩니다.</p><p>사실 자바스크립트는 함수형 스타일로 작성해야 더 효과적이라는 측면이 오랫동안 간과되었습니다. 자바스크립트라는 언어를 많이 오해한 부분도 있지만 언어 내부에 상태를 적절히 관리할 장치가 마땅치 않았던 이유도 있습니다. (상태관리를 개발자에게 떠넘기는 동적인 플랫폼이기 떄문)</p><p>결국 이는 각종 애플리케이션 버그를 양산하는 근원이 되었습니다.</p><p>FP로 코드를 작성하면 대부분의 문제가 해결됩니다. 순수함수에 기반을 두고 이미 검증된 기법과 관례에 따라 구현하면 코드가 점점 복잡해지더라도 헤아리기 쉬운 방향으로 작성할 수 있습니다.</p><h2 id="1-2-함수형-프로그래밍이란"><a href="#1-2-함수형-프로그래밍이란" class="headerlink" title="1.2 함수형 프로그래밍이란?"></a>1.2 함수형 프로그래밍이란?</h2><p>함수형 프로그래밍의 진정한 목표는 애플리케이션의 <strong>부수효과(side effect)를 방지</strong> 하고 <strong>상태변이(mutation of state)를 감소</strong>하기 위해 <strong>데이터의 제어흐름과 연산을 추상화(abstract)</strong>하는 것입니다.</p><p>간단한 예제로서 Hello world로 시작해보겠습니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#msg'</span>).innerHTML = <span class="string">'&lt;h1&gt;Hello World&lt;/h1&gt;'</span>;</span><br></pre></td></tr></tbody></table></figure></div></figure><p>이 예제는 모든 것을 하드코딩한 예제로서 메시지를 동적으로 표시할 수 없습니다. 내용이나 형식을 바꾼다든가, 타깃 요소를 달리한다든지 할 땐 표현식을 전부 재작성해야 합니다. 함수를 만들어 달라지는 부분만 매개변수로 주면 같은 코드를 다시 사용할 수 있습니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMessage</span>(<span class="params">elementId, format, message</span>) </span>{</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">${elementId}</span>`</span>).innerHTML = </span><br><span class="line">    <span class="string">`&lt;<span class="subst">${format}</span>&gt;<span class="subst">${message}</span>&lt;/<span class="subst">${format}</span>&gt;`</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">printMessage(<span class="string">'msg'</span>, <span class="string">'h1'</span>, <span class="string">'Hello World'</span>);</span><br></pre></td></tr></tbody></table></figure></div></figure><p>이런식으로 작성하면 조금 나아지는듯 하나 완벽히 재사용 가능한 코드는 아닙니다.</p><p>메시지를 HTML 페이지 대신 파일에 쓴다면 어떨까요? 매개변수가 단순히 스칼라(scalar)값이 아닌, 특정 기능을 함수에 추가하여 매개변수로 전달하는, 다시 말해 함수를 매개변수화(parameterize)하는 전혀 다른 차원의 과정을 떠올려야 합니다. 함수형 프로그래밍은 함수를 아주 왕성하게 활용합니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>함수형 printMessage</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printMessage = run(addToDom(<span class="string">'msg'</span>), h1, echo);</span><br><span class="line">printMessage(<span class="string">'Hello World'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//임시함수 run에 관한 자세한 내용은 http://mng.bz/nmax 참조</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>언뜻 봐도 기존 코드와는 다릅니다. 일단 h1은 스칼라값이 아닌, addToDom, echo와 같은 함수입니다. 작은 함수들을 재료로 새로운 함수를 만들어내는 것처럼 보입니다.</p><p>여기에는 그럴 만한 이유가 있습니다. 위 예제는 재사용성과 믿음성(reliability)이 좋고 이해하기 쉬운, 더 작은 조각들로 프로그램을 나눈 후, 전체적으로 더 헤아리기 쉬운 형태의 프로그램으로 다시 조합하는 과정을 나타냅니다.</p><p>모든 함수형 프로그래밍이 이 기본원리를 따릅니다. run함수는 세 함수를 마치 자전거 체인처럼 연결해서 한 함수의 반환값이 다른 함수의 입력값으로 전달되게끔 합니다. 그래서 echo가 “Hello World” 문자열을 반환하면 h1으로 전달되고, 마지막으로 이 함수의 결과값이 addToDom에 넘어갑니다.</p><p>함수형 코드는 왜 이런 모습일까요? 핵심개념은 본연의 기능은 그대로 간직한 채 코드 자체를 매개변수화 하는 것 입니다. 이렇게 하면 내부로직이 변경되지 않고도 printMessage를 2회 표시하거나, 또는 h2요소를 DOM대신 콘솔에 출력하는 일도 수월해 집니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>printMessage를 확장</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printMessage = run(<span class="built_in">console</span>.log, repeat(<span class="number">2</span>), h2, echo);</span><br><span class="line"></span><br><span class="line">printMessage(<span class="string">'Get Functional'</span>)</span><br></pre></td></tr></tbody></table></figure></div></figure><p>함수형/비함수형 해법을 견주어보면 근본적으로 스타일이 다르다는 것을 알 수 있습니다. 이는 FP특유의 선언적 개발방식 때문에 그렇습니다. 함수형 프로그래밍을 온전히 이해하려면, 먼저 그 이면에 깔려 있는 다음 기본 개념을 숙지해야 합니다.</p><blockquote><ul><li>선언적 프로그래밍</li><li>순수함수</li><li>참조 투명성</li><li>불변성</li></ul></blockquote><h3 id="1-2-1-함수형-프로그래밍은-선언적"><a href="#1-2-1-함수형-프로그래밍은-선언적" class="headerlink" title="1.2.1 함수형 프로그래밍은 선언적"></a>1.2.1 함수형 프로그래밍은 선언적</h3><p>함수형 프로그래밍은 큰 틀에서 선언적(declarative)프로그래밍 패러다임에 속 합니다. 내부적으로 코드를 어떻게 구현했는지, 데이터는 어떻게 흘러가는지 밝히지 않은 채 연산/작업을 표현하는 사상입니다.</p><p>아직은 C#, C++ 등의 구조적/객체지향 언어가 지원하는 <strong>명령형(imperative)</strong> 또는 <strong>절차적(procedural)</strong> 모델이 더 많이 쓰입니다. 명령형 프로그램은 위에서 아래로 축 늘어놓은 순차열 코드에 불과합니다.</p><p>숫자배열의 원소들을 모두 제곱수로 바꾸는 간단한 예제를 봅시다. 명령형은 다음과 같은 모습입니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; array.length; i++) {</span><br><span class="line">  array[i] = <span class="built_in">Math</span>.pow(array[i], <span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//array --&gt; [0,1,4,9,16,25,36,49,64,81]</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>명령형 프로그래밍은 컴퓨터에게 원하는 작업(루프를 반복하면서 각 숫자의 제곱수를 계산)을 <strong>어떻게</strong> 하는지 상세히 이릅니다. 사실 이게 가장 흔한 코딩 방법이고 여러분도 처음에 이런 코드를 떠올렸을 겁니다.</p><p>이와 달리 선언적 프로그래밍은 프로그램의 <strong>서술부(description)</strong>와 <strong>평가부(evaluation)</strong>를 분리하여, 제어 흐름이나 상태 변화를 특정하지 않고도 프로그램 로직이 무엇인지를 <strong>표현식(expression)</strong>으로 나타냅니다. (SQL 구문도 선언적 프로그래밍의 한 예)</p><p>같은 작업이라도 함수형으로 접근하면, 개발자가 <strong>각 요소를 올바르게 작동시키는 일</strong>에만 전념하고 루프 제어는 시스템의 다른 파트에 일임할 수 있습니다. 다음과 같은 힘든 일은 Array.map()에게 모두 맡기면 그만입니다.<br><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>].map(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(num, <span class="number">2</span>);</span><br><span class="line">  }</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// --&gt; [0,1,4,9,16,25,36,49,64,81]</span></span><br></pre></td></tr></tbody></table></figure></div></figure><br>이전 코드와 비교하면 루프 카운터를 관리하고 배열 인덱스에 정확하게 접근하는 일 따위는 개발자가 신경 쓸 필요가 없어 부담이 줄어듭니다.</p><p>사실 코드가 길어지면 버그가 날 가능성도 높아지고, 일반 루프는 함수로 추상하지 않는 한 재사용 자체가 안됩니다. 지금부터 우리가 할 일이 바로 <strong>함수로 추상</strong>하는 작업입니다.</p><p>3장에서는 수동 루프를 완전히 들어내고 함수를 매개변수로 받는 map, reduce, filter 같은 <strong>일급 고계함수(higher-order function)</strong>를 이용해 재사용성, 확장성이 우수한 선언적 코드로 대체합니다.</p><p>루프를 함수로 추상하면 ES6부터 새로 선보인 <strong>람다표현식(lambda expression)</strong>이나 <strong>화살표 함수(arrow fucntion)</strong>를 사용할 수 있습니다. 람다 표현식은 함수 인수로 전달 가능한 익명함수(anonymous function)를 대체할 수 있는 깔끔한 수단입니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>].map(<span class="function"><span class="params">num</span> =&gt;</span> <span class="built_in">Math</span>.pow(num, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// --&gt; [0,1,4,9,16,25,36,49,64,81]</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>왜 루프를 제거해야 할까요? 루프는 재사용하기도 어렵거니와 다른 연산에 끼워 넣기도 어려운 명령형 구조물입니다. 또 루프는 성격상 반복할 때마다 값이나 상태가 계속 바뀝니다.</p><p>그러나 함수형 프로그램은 <strong>무상태성(statelessness)</strong>과 <strong>불변성(immutability)</strong>을 지향합니다. 무상태 코드는 전역 상태를 바꾸거나 혼선을 일으킬 가능성이 단 1%도 없습니다. 상태를 두지 않으려면 부수효과와 상태 변이를 일으키지 않는 <strong>순수함수(pure funciton)</strong>를 써야합니다.</p><h3 id="1-2-2-순수함수와-부수효과"><a href="#1-2-2-순수함수와-부수효과" class="headerlink" title="1.2.2 순수함수와 부수효과"></a>1.2.2 순수함수와 부수효과</h3><p>함수형 프로그래밍은 순수함수로 구성된 불변 프로그램 구축을 전재로 합니다.<br>순수함수의 특성을 정리하면 다음과 같습니다.</p><blockquote><ul><li>주어진 입력에만 의존할 뿐, 평가 도중 또는 호출 간 변경될 수 있는 숨겨진 값이나 외부상태와 무관하게 동작합니다.</li><li>전역 객체나 레퍼런스로 전달된 매개변수를 수정하는 등 함수 스코프 밖에서 어떠한 변경도 일으키지 않습니다.<br><em>위 요건이 성립되지 않는 함수는 모두 <code>불순(impure)</code> 하다고 볼수 있습니다.</em></li></ul></blockquote><p>다음 함수를 봅시다.<br><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> ++counter;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><br>이 함수는 자신의 스코프에 없는 외부 변수 <code>counter</code>를 읽고 수정하므로 불순합니다.<br>일반적으로 외부 자원을 상대로 데이터를 읽고 쓰는 함수는 부수효과를 동반합니다.<br>Date.now()처럼 많이 쓰이는 날짜/시간 함수도 미리 헤아릴 수 있는 일정한 결과값을 내지 않기 때문에 순수함수가 아닙니다.</p><p>여기서 counter는 암시적(implicit) 전역변수를 통해 접근합니다. window객체를 지칭하는 this로 접근하기 때문에 해당함수의 런타임 콘텍스트에 따라 값이 다르게 도출 될 수 있습니다.</p><p>부수효과가 발생하는 상황은 다양합니다.</p><blockquote><ul><li>전역 범위에서 변수, 속성, 자료구조를 변경</li><li>함수의 원래 인수 값을 변경</li><li>사용자 입력을 처리</li><li>예외를 일으킨 해당 함수에서 catch하지 않고 그대로 throw함</li><li>화면 또는 로그 파일에 출력</li><li>HTML 문서, 브라우저 쿠키, DB에 질의</li></ul></blockquote><p>실제로 FP는 모든 상태변이를 근절하자는게 아니라 상태변이를 줄이고 관리할 수 있는 프레임워크를 제공하여 순수/불순 함수를 구분하고자 사용합니다.</p><p>좀 더 현실적인 예제를 들어봅시다. 당신은 학생 데이터를 관리하는 프로젝트를 참여중이며 학생 레코드를 검색하여 브라우저에 표시하는 함수를 작성한다 가정해 봅시다.<br><figure class="codeblock codeblock--tabbed"><figcaption><span>코드1-3 부수효과를 일으키는 명령형 showStudnet함수</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showStudent</span>(<span class="params">ssn</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> student = db.find(ssn);</span><br><span class="line">  <span class="keyword">if</span>(student !== <span class="literal">null</span>) {</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">${elementId}</span>`</span>).innerHTML = </span><br><span class="line">    <span class="string">`<span class="subst">${student.ssn}</span>,<span class="subst">${student.firstname}</span>,<span class="subst">${student.lastname}</span>`</span>;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'학생을 찾을 수 없습니다!'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">showStudent(<span class="string">'444-44-4444'</span>)</span><br></pre></td></tr></tbody></table></figure></div></figure><br>이 함수는 확실히 자신의 스코프를 벗어나 몇 가지 부수효과 파장을 일으킵니다.</p><ul><li>변수 db를 통해 데이터에 접근하는데, 함수 서명(signature)에는 이런 매개변수가 없으니 이는 외부 변수 입니다. 문제는 이 변수가 실행 중 언제라도 null을 참조하거나 호출 단계마다 상이한 값을 가리키면 결과값이 완전히 달라지고 프로그램 무결성이 깨질 수 있다는 점입니다.</li><li>elementId는 그 값이 언제라도 바뀔 수 있는 전역 변수라 이 함수가 어쩔 도리가 없습니다.</li><li>HTML요소를 직접 고칩니다. HTML 문서는 그 자체로 가변적인, 전역 공유자원입니다.</li><li>학생 레코드를 찾지 못해 예외를 던지면 전체 프로그램의 스택이 툭 풀리면서 종료될 것 입니다.</li></ul><p>위 함수는 외부자원에 의존하므로 코드가 유연하지 않고 다루기가 힘들뿐더러 테스트 역시 어렵습니다.<br>반면, 순수함수는 서명에 정규 매개변수(format parameter)를 빠짐 없이 명시하므로 코드를 이해하고 사용하기가 쉽습니다. 그럼, 함수형 마음가짐으로 두가지 FP원칙에 따라 코드를 개선해 봅시다. </p><blockquote><ul><li>긴 함수를 하나의 목적을 가진 짧은 함수로 각각 분리한다.</li><li>함수가 해야 할 작업에 필요한 인수를 모두 명시하여 부수효과 개수를 줄인다.</li></ul></blockquote><p>먼저 학생 레코드를 조회하는 일과 이를 화면에 그리는 일을 분리합시다. 이때 <strong>커링(curring)</strong> 이라는 기법을 사용할 것입니다. <strong>커링</strong>은 함수의 여러 인수를 부분적으로 나누어 세팅하는 것입니다. 다음 [코드1-4]는 find와 append 두 함수를 커링을 통해 쉽게 조합해서 실행 가능한 <strong>단항 함수(unary function)</strong>로 나눕니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>코드1-4 프로그램을 분해</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find 함수는 객체가 저장된 곳을 가리키는 레퍼런스와 검색할 학생 ID를 받습니다.</span></span><br><span class="line"><span class="keyword">var</span> find = curry(<span class="function">(<span class="params">db, id</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> obj = db.find(id);</span><br><span class="line">  <span class="keyword">if</span>(obj === <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'객체를 찾을 수 없습니다!'</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">//student 객체를 콤마로 분리된 문자열로 바꿉니다.</span></span><br><span class="line"><span class="keyword">var</span> csv = <span class="function"><span class="params">student</span> =&gt;</span> <span class="string">`<span class="subst">${student.ssn}</span>, <span class="subst">${student.firstname}</span> <span class="subst">${student.lastname}</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//학생 상세 정보를 페이지에 표시하려면 요소 ID, 학생 데이터가 필요합니다.</span></span><br><span class="line"><span class="keyword">var</span> append = curry(<span class="function">(<span class="params">selector, info</span>) =&gt;</span> {</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).innerHTML = info;</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></div></figure><p>한 가지만 개선했는데도 벌써 여러 가지 장점이 눈에 띄네요.</p><blockquote><ul><li>재사용 가능한 컴포넌트 3개로 나뉘어 코드가 훨씬 유연해졌습니다.</li><li>이렇게 잘게 나뉜(find-grained)함수를 재사용하면 신경 써서 관리할 코드 크기가 확 줄기 때문에 생산성을 높일 수 있습니다.</li><li>프로그램이 해야 할 일들을 고수준(high-level)에서 단계별로 명확하게 보여주는 선언적 스타일을 따르므로 코드 가독성이 향상됩니다.</li><li>무엇보다 중요한 건, HTML 객체와 상호작용을 자체 함수로 빼내어 순수하지 않은 로직을 순수함수에서 배제했다는 점입니다.</li></ul></blockquote><p>find 함수를 자세히 보면 예외를 내는 별도의 null 체크 분기문이 포함되어 있습니다. 이처럼 함수가 일관된 반환값을 보장하도록 해서 전체 함수 결과를 예측 가능한 방향으로 유도하면 여러모로 이롭습니다. 이것이 바로 <strong>참조 투명성(referential transparency)</strong>이라는 순수함수 본연의 특징입니다.</p><h3 id="1-2-3-참조-투명성과-치환성"><a href="#1-2-3-참조-투명성과-치환성" class="headerlink" title="1.2.3 참조 투명성과 치환성"></a>1.2.3 참조 투명성과 치환성</h3><p>참조 투명성은 순수함수를 정의하는 좀 더 공식적인 방법이며, 여기서 <strong>순수성(purity)</strong>이란 함수의 인수와 결과값 사이의 순수한 매핑 관례를 의미합니다. 따라서 어떤 함수가 동일한 입력을 받았을 때 동일한 결과를 내면 이를 <strong>참조 투명한</strong> 함수라고 합니다. 이러한 순수함수는 테스트하기 쉽고 <strong>전체 로직을 파악</strong>하는것도 쉽습니다. 좀 더 구체적으로 살펴볼까요? 주어진 입력을 처리해서 결과를 내는 일련의 함수들로 임의의 프로그램을 정의한다고 합시다. 의사형식(pseudo form)으로 나타내면 이런 모습이겠죠.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program = [Input] + [func1, func2, func3, ...] =&gt; Output</span><br></pre></td></tr></table></figure><p>[func1, func2, func3, …]이 모두 순수함수라면 이들이 내는 결과를 바꾸지 않고 [val1, val2, val3 …]이런 식으로 나열하여 프로그램을 쉽게 고칠 수 있습니다. 학생들의 평균 점수를 계산하는 간단한 예제를 예로 들어보겠습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = [<span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>];</span><br><span class="line"><span class="keyword">var</span> average = <span class="function">(<span class="params">arr</span>) =&gt;</span> divide(sum(arr), size(arr));</span><br><span class="line">average(input); <span class="comment">// --&gt; 90</span></span><br></pre></td></tr></table></figure><p>sum, size는 둘 다 참조 투명한 함수라서 이 표현식은 다음과 같이 입력값을 넣어 쉽게 바꿔 쓸 수 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> average = divide(<span class="number">270</span>, <span class="number">3</span>); <span class="comment">// --&gt; 90</span></span><br></pre></td></tr></table></figure><p>divide는 100% 순수함수여서 수식으로 표기할 수도 있습니다. 그래서 평균은 항상 270 / 3 = 90이겠죠. 참조 투명성 덕분에 이렇게 체계적인, 거의 수학적인 형태로 프로그램을 헤아릴 수 있는 것입니다. 다음은 전체 프로그램입니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">total, current</span>) =&gt;</span> total + current;</span><br><span class="line"><span class="comment">//reduce는 map처럼 전체 컬렉션을 반복하는 새로 나온 함수 입니다.</span></span><br><span class="line"><span class="comment">//인수가 sum 함수라서 배열 숫자를 하나씩 합한 총계를 냅니다.</span></span><br><span class="line"><span class="keyword">var</span> total = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(sum);</span><br><span class="line"><span class="keyword">var</span> size = <span class="function"><span class="params">arr</span> =&gt;</span> arr.length;</span><br><span class="line"><span class="keyword">var</span> divide = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a / b;</span><br><span class="line"><span class="keyword">var</span> average = <span class="function"><span class="params">arr</span> =&gt;</span> divide(total(arr), size(arr));</span><br><span class="line">average(input);</span><br></pre></td></tr></tbody></table></figure></div></figure><p>부수효과가 있는 함수라면 이런 일이 불가능하다는 것을 꼭 이해하시기 바랍니다. 함수 인수를 전부 명확하게 정의하면 스칼라 값을 비롯해 대부분의 경우 부수효과를 예방할 수 있지만, 객체를 레퍼런스로 넘길때 실수로 객체에 변이를 일으키지 않도록 주의해야합니다.</p><h3 id="1-2-4-불변-데이터-유지하기"><a href="#1-2-4-불변-데이터-유지하기" class="headerlink" title="1.2.4 불변 데이터 유지하기"></a>1.2.4 불변 데이터 유지하기</h3><p>불변 데이터는 한번 생성된 후에는 절대 바뀌지 않습니다. 다른 언어도 그렇듯이 문자열, 숫자 등 자바스크립트의 모든 기본형(primitive type)[원시자료형]은 처음부터 불변입니다. 그러나 배열등의 객체는 불변이 아니어서 함수 인수로 전달해도 원래 내용이 변경되어 부수효과가 발생할 소지는 남아있습니다. 배열을 정렬하는 간단한 코드를 봅시다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortDesc = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  arr.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b - a);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>얼핏 보기에 위 코드는 부수효과와 전혀 무관한, 좋은 코드 같습니다. 인수로 받은 배열의 원소를 내림차순으로 정렬하고 반환합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">sortDesc(arr); <span class="comment">// --&gt; [9,8,7,6,5,4,3,2,1];</span></span><br></pre></td></tr></table></figure><p>하지만 불행히도 상태적 함수인 Array.sort는 원본 레퍼런스가 가리키는 배열의 원소를 정렬하는 부수효과를 일으킵니다. 이는 언어적 결함이기도 한데, 이를 극복하는 방안은 다음 장 이후에 논의합니다. 함수형 프로그래밍을 대략 엿보았으니 이제 좀 더 간명하게 정의를 내리겠습니다. </p><blockquote><p>함수형 프로그래밍은, 외부에서 관찰 가능한 부수효과가 제거된 불변 프로그램을 작성하기 위해 순수함수를 선언적으로 평가하는 것입니다.</p></blockquote><p>오늘날 자바스크립트 개발자가 직면한 문제의 원인은, 대부분 뚜렷한 체계 없이 분기 처리를 남발하고 외부 공유 변수에 지나치게 의존하는 덩치 큰 함수를 과용하는데 있습니다. 안타깝게도 아직도 많은 자바스크립트 애플리케이션이 이런 딱한 상황에 처해 있고, 심지어 성공적이라는 작품조차 많은 파일이 한데 뒤섞여 추적/디버깅이 어려운 가변/전역 데이터를 공유하는 촘촘한 그물망이 형성된 경우가 있습니다.</p><p>함수를 순수 연산의 관점에서 고정된 <strong>작업 단위(unit of work)</strong>로 바라본다면 확실히 잠재적인 버그는 줄게 될 것입니다. 함수형 프로그래밍을 도입해서 반드시 이익을 보려면, 복잡성을 극복하는 길로 안내하는 함수형 프로그래밍의 핵심 원리를 반드시 이해해야 합니다.</p><h2 id="1-3-함수형-프로그래밍의-좋은-점"><a href="#1-3-함수형-프로그래밍의-좋은-점" class="headerlink" title="1.3 함수형 프로그래밍의 좋은 점"></a>1.3 함수형 프로그래밍의 좋은 점</h2><p>이 절에서는 <strong>함수형 인지력</strong>을 향상시키고자 핵심 기법 몇 가지를 소개합니다. FP로 개발한 자바스크립트 애플리케이션은 어떤 점이 좋은지 고수준에서 살펴봅시다. 다음 세 가지 측면에서 하위 절로 나누어 살펴보겠습니다.</p><blockquote><ul><li>간단한 함수들로 작업을 분해한다</li><li>흐름 체인(fluent chain)으로 데이터를 처리한다.</li><li>리액티브 패러다임을 실현하여 이벤트 중심 코드의 복잡성을 줄인다.</li></ul></blockquote><h3 id="1-3-1-복잡한-작업을-분해하도록-유도"><a href="#1-3-1-복잡한-작업을-분해하도록-유도" class="headerlink" title="1.3.1 복잡한 작업을 분해하도록 유도"></a>1.3.1 복잡한 작업을 분해하도록 유도</h3><p>함수형 프로그래밍은 고수준에서 보면, 사실상 분해(프로그램을 작은 조각들로 쪼갬)와 합성(작은 조각들을 다시 합침) 간의 상호작용이라 할 수 있습니다. 이러한 양면성(duality) 덕분에 함수형 프로그램은 하나의 모듈로서 효율적으로 동작합니다. 모듈성의 단위, 곧 <strong>작업 단위</strong>는 바로 함수 자신입니다.</p><p>FP에서 모듈화(modularization)는 <strong>단일성(singularity)</strong>의 원리와 밀접한 관련이 있습니다. 모름지기 함수는 저마다 한 가지 목표만 바라봐야 한다는 사상이지요. 이제 함수를 묶을 때 사용했던 run함수라는 흑마술의 내막을 밝힐 때가 되었네요. run은 이 책에서 가장 중요한 <strong>합성(composition)</strong>이라는 기법을 구현한 함수로, 두 함수를 합성하면 첫 번째 함수의 결과를 다음 함수에 밀어 넣는 새로운 함수가 탄생합니다. 두 함수 f, g의 합성 함수를 수학적으로 쓰면 다음과 같습니다.</p><blockquote><p>f · g = f(g(x))</p></blockquote><p>이 수식은 <code>f 합성 g</code>라고 읽습니다. 이로써 g의 반환값과 f의 인수 간에 느슨하고(loose) 형식 안전한(type-safe) 관계가 맺어집니다. 두 함수를 섞어 쓰려면 당연히 인수 개수와 형식이 맞아야 겠지요? 자세한 내용은 3장에서 다시 이어지니, 지금은 함수명을 compose로 바로잡고 showStudent의 합성을 도식화한 [그림 1-4]를 봅시다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var showStudent = compose(append(&apos;#student-info&apos;), csv, find(db));</span><br><span class="line"></span><br><span class="line">showStudent(&apos;444-44-4444&apos;);</span><br></pre></td></tr></table></figure></p><blockquote><p>그림 추가할 것</p></blockquote><p><em>[함수를 합성한 상태에서의 데이터 흐름] find의 반환값은 csv에 전달하는 인수,형식,개수가 일치해야 하며, csv역시 append가 사용가능 한 값을 전달해야 합니다.</em></p><p>compose함수는 함수형 애플리케이션의 모듈성과 재사용성을 학습하는데 매우 각별한 의미를 지닙니다. 함수형으로 합성한 코드는 전체 표현식의 의미를 개별 조각의 의미에서 추론할 수 있습니다. 또한 함수 합성은 고수준의 추상화를 통해 자세한 내막을 밝히지 않아도 코드가 수행하는 전 단계를 일목요연하게 나타냅니다. compose는 다른 함수를 인수로 받으므로 <strong>고계함수(higher-order-function)</strong>라고 합니다. 다음 절에서는 체인을 걸 듯 연산을 연결하여 연산 순차열을 만드는 방법을 살펴보겠습니다.</p><h3 id="1-3-2-데이터를-매끄럽게-체이닝하여-처리"><a href="#1-3-2-데이터를-매끄럽게-체이닝하여-처리" class="headerlink" title="1.3.2 데이터를 매끄럽게 체이닝하여 처리"></a>1.3.2 데이터를 매끄럽게 체이닝하여 처리</h3><p><strong>체인(chain)</strong>은 같은 객체를 반환하는 순차적인 함수 호출입니다. 체인도 합성처럼 코드를 간결명료하게 작성하게 하고, 함수형은 물론 리액티브 자바스크립트 라이브러리에서도 활발히 쓰입니다. 이번에는 수강과목이 2개 이상인 학생들의 평균 점수를 계산하는 프로그램을 작성해보겠습니다. 과목 수와 평균 점수 데이터는 다음과 같습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enrollment = [</span><br><span class="line">  &#123;<span class="attr">enrolled</span>: <span class="number">2</span>, <span class="attr">grade</span>: <span class="number">100</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">enrolled</span>: <span class="number">2</span>, <span class="attr">grade</span>: <span class="number">80</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">enrolled</span>: <span class="number">1</span>, <span class="attr">grade</span>: <span class="number">89</span>&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>명령형으로 짜면 이런 코드가 되겠죠.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> totalGrades = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> totalStudentsFound = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;enrollment.length; i++) &#123;</span><br><span class="line"> <span class="keyword">let</span> student = enrollment[i];</span><br><span class="line"> <span class="keyword">if</span>(student !== <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span>(student.enrolled &gt; <span class="number">1</span>) &#123;</span><br><span class="line">     totalGrades += student.grade;</span><br><span class="line">     totalStudentsFound++;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> average = totalGrades / totalStudentsFound; <span class="comment">// --&gt; 90</span></span><br></pre></td></tr></table></figure></p><p>좀 전에 보았던 예제처럼 함수형 마음가짐으로 이문제를 분해하면 대략 세 가지 단계를 거쳐야 합니다.</p><blockquote><ul><li>(수강 과목이 2개 이상인) 자료 집합을 적절히 선택합니다.</li><li>학생의 점수를 얻습니다.</li><li>평균 점수를 계산합니다.</li></ul></blockquote><p>각 단계에 해당하는 함수를 lodash.js로 묶으면 [코드 1-5]같은 함수 체인이 형성됩니다. 함수 체인은 필요한 시점까지 실행을 미루는 <strong>느긋한 평가(lazy evaluation; 게으른 평가)</strong>를 수행합니다. 다른 데에선 전혀 쓸 일이 없는 일련의 코드를 전부 실행하지 않아도 되니 CPU 부하가 줄어들어 성능이 좋아지죠. 이러게 하면 다른 함수형 언어에 기본 탑재된 <strong>필요 시 호출(call-by-need)</strong> 동작을 효과적으로 모방할 수 있습니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>코드 1-5 함수 체인으로 프로그래밍</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.chain(enrollment)</span><br><span class="line">   .filter(<span class="function"><span class="params">student</span> =&gt;</span> student.enrolled &gt; <span class="number">1</span>)</span><br><span class="line">   .pluck(<span class="string">'grade'</span>)</span><br><span class="line">   .average()</span><br><span class="line">   .value(); <span class="comment">// --&gt; 90</span></span><br><span class="line">   <span class="comment">//_.value()를 호출해야 체인에 연결된 모든 연산들이 실행됩니다.</span></span><br><span class="line">   <span class="comment">//lodash 4.0 부터 pluck사라짐. map()으로 대체 가능 (원래 기능은 반복가능한 JSON 배열을 일반 배열로 추려주는 기능을 함)</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>지금은 이 코드의 로직을 너무 깊이 파고들 필요가 없습니다. 명령형 프로그램에서 변수를 선언하여 그 값을 바꾸고, 루프를 반복하고, if-else 구문으로 분기했던 일들을 더 이상 할 필요가 없다는 사실만 기억하기 바랍니다.</p><p>하지만 공정하게 보자면 위 예제는 에러 처리 코드를 모두 무시하고 건너뛰었습니다. 예외를 던지는 건 부수효과를 유발한다고 했었죠. 순수 학문적인 함수형 프로그래밍에는 예외가 존재하지 않지만, 실세계에서 예외를 완전히 배제하기란 어렵습니다. 순수 에러 처리와 예외 처리는 구별해야 하는데, 어쨌든 우리의 목표는 가급적 순수 에러 처리를 하도록 구현하고, 이전 코드처럼 진짜 예외적인 상황에서는 예외가 나게끔 허용하는 것입니다.</p><h3 id="1-3-3-복잡한-비동기-애플리케이션에서도-신속하게-반응"><a href="#1-3-3-복잡한-비동기-애플리케이션에서도-신속하게-반응" class="headerlink" title="1.3.3 복잡한 비동기 애플리케이션에서도 신속하게 반응"></a>1.3.3 복잡한 비동기 애플리케이션에서도 신속하게 반응</h3><p>원격 데이터 조회, 사용자 입력 데이터 처리, 지역 저장소와 연동… 이런 일들을 경험한 독자라면 비지니스 로직이 콜백헬로 뒤범벅 되었던 끔찍한 기억을 떠올릴지도 모르겠습니다. 콜백 패턴은 성공/실패 처리 로직이 중첩된 형태로 흩뿌려져 있기 대문에 코드의 선형 흐름이 깨지고 무슨 일을 하는지 파악하기 어렵습니다.</p><p>최근에는 리액티브 프로그래밍 패러다임을 따르는 프레임워크에 더 많은 관심이 쏠리고 있습니다. 앵귤러JS 같은 웹 프레임워크가 아직 널리 쓰이고 있긴 하지만, RxJS 처럼 FP의 강력한 장점으로 무장하여 난제를 척척 해결하는 신흥 강자들이 실무에 등장하고 있습니다.</p><p>리액티브 패러다임의 가장 큰 장점은, 더 높은 수준으로 코드를 추상화하여 반복되는 판박이(boilerplate) 코드는 아에 잊고 비지니스 로직에만 전념할 수 있게 해준다는 것 입니다.</p><p>어떤 학생의 SSN이 올바른 번호인지 검증하는 함수를 만들어 봅시다. 명령형으로 생각하면 다음 [코드1-6]과 같습니다.<br><figure class="codeblock codeblock--tabbed"><figcaption><span>코드1-6 학생의 SSN을 읽고 올바른지 검증하는 명령형 프로그램</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> valid = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.querySelector(<span class="string">'#student-ssn'</span>);</span><br><span class="line">elem.onkeyup = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> val = event.value;</span><br><span class="line">  <span class="keyword">if</span>(val !== <span class="literal">null</span> &amp;&amp; val.length !== <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">//입력 데이터를 정제/변경합니다.</span></span><br><span class="line">    val = val.replace(<span class="regexp">/^\s*|\s*$|\-s/g</span>, <span class="string">''</span>);</span><br><span class="line">    <span class="keyword">if</span>(val.length === <span class="number">9</span>) {</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`올바른 SSN : <span class="subst">${val}</span>!`</span>);</span><br><span class="line">      <span class="comment">//아래 줄 코드에서는 함수 스코프 바깥 데이터에 접근하는 부수효과 발생</span></span><br><span class="line">      valid = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`잘못된 SSN: <span class="subst">${val}</span>!`</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><br>하려는 일은 단순한데 코드는 적잖이 복잡해 보이고, 게다가 비즈니스 로직이 모두 한곳에 집중되어 있어 모듈성도 결여되어 있습니다. 무엇보다 이 함수는 외부 상태에 의존하는 탓에 재사용이 어렵습니다. 함수형 프로그래밍에 기반을 둔 리액티브 프로그램은 순수함수를 이용하여 map, reduce처럼 많이 쓰는 연산으로 데이터를 처리할 수 있고 람다 표현식의 간결함을 누릴 수 있다는 이점이 있습니다.</p><p>리액티브 패러다임은 <strong>옵져버블(observable; 관찰가능)</strong>이라는 아주 중요한 장치를 매개로 움직입니다. 옵저버블을 이용하면 데이터 스트림을 구독해서 원하는 연산을 우아하게 합성 및 체이닝(chaining)하여 처리할 수 있습니다. 학생 SSN 입력 필드를 구독하는 간단한 예를 봅시다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>코드 1-7 학생의 SSN을 읽고 올바른지 검증하는 함수형 프로그램</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(<span class="built_in">document</span>.querySelector(<span class="string">'#student-ssn'</span>), <span class="string">'keyup'</span>)</span><br><span class="line"> .pluck(<span class="string">'srcElement'</span>, <span class="string">'value'</span>)</span><br><span class="line"> .map(<span class="function"><span class="params">ssn</span> =&gt;</span> ssn.replace(<span class="regexp">/^\s*|\s*$|\-s/g</span>, <span class="string">''</span>))</span><br><span class="line"> .filter(<span class="function"><span class="params">ssn</span> =&gt;</span> ssn !== <span class="literal">null</span> &amp;&amp; ssn.length === <span class="number">9</span>)</span><br><span class="line"> .subscribe(<span class="function"><span class="params">validSsn</span> =&gt;</span> {</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">`올바른 SSN <span class="subst">${validSsn}</span>!`</span>);</span><br><span class="line"> })</span><br></pre></td></tr></tbody></table></figure></div></figure><p>[코드 1-7]에서 가장 주목해야 할 부분은, 수행하는 모든 연산이 완전한 불변이고 비즈니스 로직은 모두 개별 함수로 나뉘었다는 점입니다. 굳이 리액티브/함수형을 섞어 쓸 필요는 업지만, 함수형으로 사고하다 보면 두 가지를 혼용하게 되어 결국 <strong>함수형 리액티브 프로그래밍(functional reactive programming; FRP)</strong>이라는 정말 기막힌 아키텍처에 눈을 뜨게 됩니다.</p><p>FP는 불변성과 공유 상태를 엄격하게 통제하므로 멀티스레드 프로그램보다 직관적으로 작성 할 수 있습니다. 자바스크립트는 싱글스레드로 작동하는 플랫폼이므로 멀티스레드는 우리가 걱정하거나 이 책에서 다룰 주제는 아닙니다. 앞의 내용들을 잘 따라오셨다면 앞으로는 모든 문제를 <code>함수형</code>으로 바라보기 시작해야 합니다.</p><h2 id="1-4-마치며"><a href="#1-4-마치며" class="headerlink" title="1.4 마치며"></a>1.4 마치며</h2><blockquote><p>순수함수를 사용한 코드는 전역 상태를 바꾸거나 깨뜨릴 일이 전혀 없으므로 테스트, 유지보수가 더 쉬운 코드를 개발하는 데 도움이 됩니다.</p></blockquote><blockquote><p>함수형 프로그래밍은 코드를 선언적으로 작성하므로 헤아리기 쉽고 전체 애플리케이션의 가독성 역시 향상됩니다. 또 함수와 람다 표현식을 조합하여 깔끔하게 코딩할 수 있습니다.</p></blockquote><blockquote><p>여러 원소로 구성된 컬렉션 데이터는 map, reduce 같은 연산을 함수 체인으로 연결하여 물 흐르듯 매끄럽게 처리할 수 있습니다.</p></blockquote><blockquote><p>함수형 프로그래밍은 함수를 기본적인 구성 요소로 취급합니다. 이는 일급/고계함수 개념에 기반을 두며 코드의 모듈성, 재사용성을 높입니다.</p></blockquote><blockquote><p>리액티브/함수형 프로그래밍을 융합하면 이벤트 기반 프로그램 특유의 복잡성을 줄일 수 있습니다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;함수형 자바스크립트 - 스터디 정리 Chapter 1 (함수형 길들이기)&lt;br&gt;
    
    </summary>
    
      <category term="FunctionalProgramming" scheme="http://ksw1652.github.io/categories/FunctionalProgramming/"/>
    
    
      <category term="함수형자바스크립트" scheme="http://ksw1652.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="FunctionalProgrammingInJavascript" scheme="http://ksw1652.github.io/tags/FunctionalProgrammingInJavascript/"/>
    
  </entry>
  
  <entry>
    <title>codility lesson 04 CountingElements MissingInteger</title>
    <link href="http://ksw1652.github.io/2018/11/03/codility-lesson-04-CountingElements-MissingInteger/"/>
    <id>http://ksw1652.github.io/2018/11/03/codility-lesson-04-CountingElements-MissingInteger/</id>
    <published>2018-11-03T09:55:33.000Z</published>
    <updated>2019-03-15T07:00:21.093Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></missinginteger></p><hr><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><blockquote><p>This is a demo task.</p><p>Write a function:</p><p>function solution(A);</p><p>that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.</p><p>For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.</p><p>Given A = [1, 2, 3], the function should return 4.</p><p>Given A = [−1, −3], the function should return 1.</p><p>Write an efficient algorithm for the following assumptions:</p><p>N is an integer within the range [1..100,000];<br>each element of array A is an integer within the range [−1,000,000..1,000,000].</p></blockquote><hr><p>문제해설 : N개의 integer들로 구성된 배열 A가 주어지고 함수 solution은 가장 작은 양의정수(0 보다 크고 배열 A에는 없는)를 리턴한다.</p><p>예를 들어 A = [1, 3, 6, 4, 1, 2] 이면, 함수는 5를 리턴해야 한다.</p><p>A = [1, 2, 3] 이면 함수는 4를 리턴한다.</p><p>A = [−1, −3] 이면 함수는 1을 리턴한다.</p><p>다음 가정에 대해 가장 효율 적인 알고리즘을 작성하라.</p><ul><li>N은 1 ~ 100,000의 범위를 가지는 integer이다.</li><li>배열 A의 각 요소는 -1,000,000 ~ 1,000,000의 범위를 가지는 integer이다.</li></ul><hr><h2 id="답안-해설"><a href="#답안-해설" class="headerlink" title="답안 해설"></a>답안 해설</h2><p>내가 작성한 코드 :</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">js</li></ul></figcaption><div class="tabs-content"><figure class="highlight js" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">A</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">var</span> N = A.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; N; i++){</span><br><span class="line">        myMap.set(i, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; A.length; i++) {</span><br><span class="line">        <span class="keyword">var</span> v = A[i];</span><br><span class="line">        myMap.set(v<span class="number">-1</span>, <span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> myMap) {</span><br><span class="line">        <span class="keyword">if</span>(!value) <span class="keyword">return</span> key + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> myMap.size + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>배열 A는 중복 된 숫자도 허용하며 음의 정수도 포함 할 수 있다.<br>처음 생각해낸 방법은 javascript의 정렬 함수를 사용한 다음, 없는 숫자를 체크하려 했으나<br>대략적인 시간복잡도를 계산해보면 O(NlogN)이 된다.<br>이 방법도 가능하겠지만 정렬없이 체크할 수 있는방법을 생각해내게 되었다.</p><p><strong>배열 A의 값의 존재유무를 체크 할 수 있는 Map객체로 구현하였다.</strong></p><p>myMap이라는 map객체를 하나 만든 후, 배열 A의 길이만큼 key:value –&gt; index:false 로 초기화 한다.<br>이후 배열 A를 순회하면서 v라는 변수에 A의 각 요소를 넣고 이를 myMap에 set한다.<br>즉, A 요소의 값이 myMap의 인덱스로서 체크 되는 것.</p><p>체크가 완료된 후 myMap의 첫 index부터 순회하면서 false라면 바로 (해당 키 값 + 1)을 리턴하며, 배열의 value가 모두 true이면 마지막 값 + 1을 리턴 한다.</p><p>시간 복잡도의 경우 최선의 케이스는 O(N)이며 최악의 케이스는 O(Nlog(N))이 된다.</p><h2 id="실행결과"><a href="#실행결과" class="headerlink" title="실행결과"></a>실행결과</h2><div class="figure center" style="width:100%;"><a class="fancybox" href="codility-lesson-4-missing-integer-1.png" title="" data-caption="" data-fancybox="codility"><img class="fig-img" src="codility-lesson-4-missing-integer-1.png" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div><div class="figure center" style="width:100%;"><a class="fancybox" href="codility-lesson-4-missing-integer-2.png" title="" data-caption="" data-fancybox="codility"><img class="fig-img" src="codility-lesson-4-missing-integer-2.png" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Codility의 네 번째 lesson의 마지막 문제 &lt;missinginteger&gt;&lt;br&gt;
    
    </summary>
    
      <category term="코딩테스트" scheme="http://ksw1652.github.io/categories/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
    
      <category term="이직" scheme="http://ksw1652.github.io/tags/%EC%9D%B4%EC%A7%81/"/>
    
      <category term="코딜리티" scheme="http://ksw1652.github.io/tags/%EC%BD%94%EB%94%9C%EB%A6%AC%ED%8B%B0/"/>
    
      <category term="코테" scheme="http://ksw1652.github.io/tags/%EC%BD%94%ED%85%8C/"/>
    
  </entry>
  
  <entry>
    <title>codility lesson 03 TimeComplexity PermMissingElem</title>
    <link href="http://ksw1652.github.io/2018/10/11/codility-lesson-03-TimeComplexity-PermMissingElem/"/>
    <id>http://ksw1652.github.io/2018/10/11/codility-lesson-03-TimeComplexity-PermMissingElem/</id>
    <published>2018-10-11T00:37:33.000Z</published>
    <updated>2018-11-03T09:25:46.176Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><hr><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><blockquote><p>An array A consisting of N different integers is given. The array contains integers in the range [1..(N + 1)], which means that exactly one element is missing.</p><p>Your goal is to find that missing element.</p><p>Write a function:</p><p>function solution(A);</p><p>that, given an array A, returns the value of the missing element.</p><p>For example, given array A such that:</p><p>  A[0] = 2<br>  A[1] = 3<br>  A[2] = 1<br>  A[3] = 5<br>the function should return 4, as it is the missing element.</p><p>Write an efficient algorithm for the following assumptions:</p><p>N is an integer within the range [0..100,000];<br>the elements of A are all distinct;<br>each element of array A is an integer within the range [1..(N + 1)].</p></blockquote><hr><p>문제해설 : 각각 다른 integer N으로 주어진 배열 A가 존재합니다.. 이 배열은 [1…(N + 1)]의 범위를 가지고 하나의 요소가 비어있습니다.<br>당신의 목표는 비어있는 요소를 찾아내는 것입니다.</p><p>함수 solution(A)를 작성하세요.</p><p>주어진 배열 A에서 비어있는 요소를 리턴하세요</p><p>예를 들면 배열 A는 다음과 같습니다.</p><p>  A[0] = 2<br>  A[1] = 3<br>  A[2] = 1<br>  A[3] = 5</p><p>함수는 비어있는 요소 4를 리턴해야 합니다.</p><p>다음 가정을 토대로 효율적인 알고리즘을 작성하세요.</p><ul><li>N은 integer이며 [0…100,000]의 범위를 가집니다.</li><li>배열 A의 요소는 모두 서로 다릅니다.</li><li>배열 A의 각 요소는 [1…(N + 1)]의 범위의 integer입니다.</li></ul><hr><h2 id="답안-해설"><a href="#답안-해설" class="headerlink" title="답안 해설"></a>답안 해설</h2><p>내가 작성한 코드 :</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">js</li></ul></figcaption><div class="tabs-content"><figure class="highlight js" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">A</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span>(A.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sortedArr = A.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>{<span class="keyword">return</span> a - b});</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> sortedArr) {</span><br><span class="line"><span class="keyword">if</span>(sortedArr[<span class="number">0</span>] !== <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sortedArr[i] !== i + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>주어진 배열 A를 정렬할 sortedArr 배열을 생성하였다.<br>for문을 순회하면서 각 배열의 요소가 index+1이 아니면 순회를 멈추고 해당 index + 1값 즉, 비어있는 값을 리턴한다.<br>기본적인 로직은 위와 같고 예외 케이스를 처리해 주었다.<br>비어 있는 값이 1일 경우 순회를 전부 할 필요도 없기 때문에 바로 리턴해주었다.</p><p>테스트 결과를 제출하고 성적을 받아보았는데 90%이다…<br>이유를 찾아보니 empty list and single element 케이스에서 런타임 에러가 났다.<br>예외처리를 더 해주지 않은 것이다.<br>이유를 찾아보니 배열의 길이가 0인 케이스도 생각해주어야 한다.<br>(당연히 배열은 빈배열이 아닐 줄 알았는데…)<br>A = [];<br>이 케이스의 경우 비어있는 값은 1이 되므로 맨 위쪽에서 바로 리턴해 주었다.<br>테스트 결과 100%가 되었으며 시간 복잡도는 최선일 경우 O(N)이며 최악의 경우는O(N * log(N))이다.</p><hr><p>다른 방법으로 작성한 코드 :</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">js</li></ul></figcaption><div class="tabs-content"><figure class="highlight js" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">A</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> N = A.length + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> tot = N * (N + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> A) {</span><br><span class="line">  sum += item</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tot - sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>1 ~ N + 1까지의 합을 구한 후 배열 A의 모든 요소를 더한 값을 빼면 비어있는 값을 얻을 수 있다.</p>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Codility의 세 번째 lesson의 PermMissingElem 문제를 풀어보았다.&lt;br&gt;
    
    </summary>
    
      <category term="코딩테스트" scheme="http://ksw1652.github.io/categories/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
    
      <category term="이직" scheme="http://ksw1652.github.io/tags/%EC%9D%B4%EC%A7%81/"/>
    
      <category term="코딜리티" scheme="http://ksw1652.github.io/tags/%EC%BD%94%EB%94%9C%EB%A6%AC%ED%8B%B0/"/>
    
      <category term="코테" scheme="http://ksw1652.github.io/tags/%EC%BD%94%ED%85%8C/"/>
    
  </entry>
  
  <entry>
    <title>codility lesson 02 OddOccurrencesInArray</title>
    <link href="http://ksw1652.github.io/2018/10/10/codility-lesson-02-OddOccurrencesInArray/"/>
    <id>http://ksw1652.github.io/2018/10/10/codility-lesson-02-OddOccurrencesInArray/</id>
    <published>2018-10-10T09:49:53.000Z</published>
    <updated>2019-03-15T06:59:50.602Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><hr><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><blockquote><p>A non-empty array A consisting of N integers is given. The array contains an odd number of elements,</p><p>and each element of the array can be paired with another element that has the same value, except for one element that is left unpaired.</p><p>For example, in array A such that:</p><p>  A[0] = 9  A[1] = 3  A[2] = 9<br>  A[3] = 3  A[4] = 9  A[5] = 7<br>  A[6] = 9<br>the elements at indexes 0 and 2 have value 9,<br>the elements at indexes 1 and 3 have value 3,<br>the elements at indexes 4 and 6 have value 9,<br>the element at index 5 has value 7 and is unpaired.<br>Write a function:</p><p>function solution(A);</p><p>that, given an array A consisting of N integers fulfilling the above conditions, returns the value of the unpaired element.</p><p>For example, given array A such that:</p><p>  A[0] = 9  A[1] = 3  A[2] = 9<br>  A[3] = 3  A[4] = 9  A[5] = 7<br>  A[6] = 9<br>the function should return 7, as explained in the example above.</p><p>Write an efficient algorithm for the following assumptions:</p><p>N is an odd integer within the range [1..1,000,000];<br>each element of array A is an integer within the range [1..1,000,000,000];<br>all but one of the values in A occur an even number of times.</p></blockquote><hr><p>문제해설 : 비어있지 않은 배열 A는 integers N으로 구성되어 있습니다.</p><p>배열은 홀수 개의 요소가 포함되어 있으며, 각 요소는 한개의 요소를 제외하고, 다른 요소와 같은 값으로서 쌍을 이룰 수 있습니다.</p><p>예를 들어 배열 A는 다음과 같습니다.</p><p>A[0] = 9<br>A[1] = 3<br>A[2] = 9<br>A[3] = 3<br>A[4] = 9<br>A[5] = 7<br>A[6] = 9</p><p>인덱스 0과 2의 값은 3 입니다.<br>인덱스 4와 6의 값은 9 입니다.<br>인덱스 5의 값은 7이며 쌍을 이루지 않습니다.</p><p>다음 solution(A) 함수를 작성하세요.</p><p>위 조건을 만족하는 N integers로 구성된 배열 A는 쌍을 이루지 않는 값을 리턴합니다.</p><p>예를 들면 주어진 배열 A는</p><p>A[0] = 9<br>A[1] = 3<br>A[2] = 9<br>A[3] = 3<br>A[4] = 9<br>A[5] = 7<br>A[6] = 9</p><p>위 설명대로라면 7을 리턴합니다.</p><p>다음 가정을 토대로 효율적인 알고리즘을 작성하세요.</p><ul><li>N은 [1…1,000,000]의 범위를 가진 홀수 입니다.</li><li>배열 A의 각 요소는 [1..1,000,000,000]의 범위를 가집니다.</li><li>A의 값 중 하나를 제외하고 모두 짝수 번 발생합니다.</li></ul><hr><h2 id="답안-해설"><a href="#답안-해설" class="headerlink" title="답안 해설"></a>답안 해설</h2><p>내가 작성한 코드 :</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">js</li></ul></figcaption><div class="tabs-content"><figure class="highlight js" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">A</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; A.length; i++) {</span><br><span class="line">        <span class="keyword">var</span> foundVal = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> {</span><br><span class="line">            <span class="keyword">return</span> item.value === A[i];</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(foundVal == <span class="literal">undefined</span>) {</span><br><span class="line">            arr.push({</span><br><span class="line">                value: A[i],</span><br><span class="line">                count: <span class="number">1</span></span><br><span class="line">            });</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            foundVal.count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> {</span><br><span class="line">        <span class="keyword">return</span> item.count % <span class="number">2</span> !== <span class="number">0</span></span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>내가 생각한 접근법은 배열을 새로 만들고 각 배열의 요소에 대한 count를 저장한다.<br>배열 A를 순회하면서 중복되는 값의 count는 증가할 것이고 배열 A를 전부 순회하였을 때, 2로 나눠지지 않는 값을 찾는다.<br>시간 복잡도는 배열 A를 순회하면서 이에 매칭되는 값을 저장하는 arr도 순회해야 하기 때문에 O(N^2)가 된다.</p><p>P.S 상당히 고민 끝에 푼 테스트였는데 결과도 좋지 않아 현타가 왔다.</p><p>Test Score는 66%였으며 Performance tests에서 medium, big1, big2에서 Timeout error가 났다.</p><div class="figure center" style="width:100%;"><a class="fancybox" href="codility-oddoccurrences-01.png" title="" data-caption="" data-fancybox="codility"><img class="fig-img" src="codility-oddoccurrences-01.png" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div><div class="figure center" style="width:100%;"><a class="fancybox" href="codility-oddoccurrences-02.png" title="" data-caption="" data-fancybox="codility"><img class="fig-img" src="codility-oddoccurrences-02.png" style="width:100%;height:100%;" alt=""></a></div><div style="clear:both;"></div><p>도대체 어떻게 효율적으로 짤 수 있을까 생각하다 결국엔 답을 찾아보았다.<br>답을 찾아보고 난후 더욱 맨붕이 심하게 왔다…<br>봐도 이해가 가지 않았기 때문…</p><p>이 문제에 대한 최적의 알고리즘은 다음과 같다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">js</li></ul></figcaption><div class="tabs-content"><figure class="highlight js" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">A</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> A) {</span><br><span class="line">        result ^= item;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>(코드가 어찌 이리 간단하면서도 이해가 가지 않을 수가 있지??!?)<br>(저기서 XOR연산을 왜 하는거지??)<br>결론은 간단했다. XOR (배타적 논리합: XOR연산은 두 개의 비트 값이 다르면 1, 같으면 0을 돌려준다) 연산의 특성 때문에 자체적으로 쌍을 이루지 않는 값은 필터링이 된다.<br>XOR연산은 다음과 같은 특성을 가진다.</p><ul><li>X^0 = X</li><li>X ^ X = 0</li></ul><p>즉 같은 값을 XOR연산을 한다면 그 값은 0이 되며 0과 X의 XOR 연산은 자기 자신이 된다.</p><p>예를 들어 3^0의 경우</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span></span><br><span class="line"><span class="number">0011</span></span><br><span class="line">----</span><br><span class="line"><span class="number">0011</span></span><br></pre></td></tr></table></figure><p>본인과 같은 3이 되고,<br><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0011</span></span><br><span class="line"><span class="number">0011</span></span><br><span class="line">----</span><br><span class="line"><span class="number">0000</span></span><br></pre></td></tr></table></figure><p>둘다 같은 비트이기 때문에 0이 된다.</p><p>즉 위 문제의 배열 A에서 1개의 요소만 쌍을 이루지 않고 나머지는 모두 같은 값이므로</p><p>A[0]^A[1]^A[2]….A[N-1]^A[N] 이 되며<br>쌍을 이루는 값들은 XOR연산에 의해 0으로,<br>쌍을 이루지 못한 요소는 그대로 남게되어<br>0^A[X] = A[X] 가 된다.<br>결국 쌍을 이루지 못한 값만 남게 되는것이다.</p><p>출처 : <a href="https://codesays.com/2014/solution-to-perm-missing-elem-by-codility/" target="_blank" rel="noopener">Solution to Odd-Occurrences-In-Array by codility</a></p>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Codility의 두 번째 lesson의 두번째 문제. OddOccurrencesInArray&lt;br&gt;
    
    </summary>
    
      <category term="코딩테스트" scheme="http://ksw1652.github.io/categories/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
    
      <category term="이직" scheme="http://ksw1652.github.io/tags/%EC%9D%B4%EC%A7%81/"/>
    
      <category term="코딜리티" scheme="http://ksw1652.github.io/tags/%EC%BD%94%EB%94%9C%EB%A6%AC%ED%8B%B0/"/>
    
      <category term="코테" scheme="http://ksw1652.github.io/tags/%EC%BD%94%ED%85%8C/"/>
    
  </entry>
  
  <entry>
    <title>codility lesson 02 array cyclerotation</title>
    <link href="http://ksw1652.github.io/2018/08/30/codility-lesson-02-array-cyclerotation/"/>
    <id>http://ksw1652.github.io/2018/08/30/codility-lesson-02-array-cyclerotation/</id>
    <published>2018-08-30T07:36:10.000Z</published>
    <updated>2018-11-03T09:25:46.163Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h1 id="Codility-Lesson-2-Array-CycleRotation"><a href="#Codility-Lesson-2-Array-CycleRotation" class="headerlink" title="Codility Lesson 2 Array - CycleRotation"></a>Codility Lesson 2 Array - CycleRotation</h1><hr><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><blockquote><p>An array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is moved to the first place. For example, the rotation of array A = [3, 8, 9, 7, 6] is [6, 3, 8, 9, 7] (elements are shifted right by one index and 6 is moved to the first place).</p><p>The goal is to rotate array A K times; that is, each element of A will be shifted to the right K times.</p><p>Write a function:</p><p>function solution(A, K);</p><p>that, given an array A consisting of N integers and an integer K, returns the array A rotated K times.</p><p>For example, given</p><pre><code>A = [3, 8, 9, 7, 6]K = 3</code></pre><p>the function should return [9, 7, 6, 3, 8]. Three rotations were made:</p><pre><code>[3, 8, 9, 7, 6] -&gt; [6, 3, 8, 9, 7][6, 3, 8, 9, 7] -&gt; [7, 6, 3, 8, 9][7, 6, 3, 8, 9] -&gt; [9, 7, 6, 3, 8]</code></pre><p>For another example, given</p><pre><code>A = [0, 0, 0]K = 1</code></pre><p>the function should return [0, 0, 0]</p><p>Given</p><pre><code>A = [1, 2, 3, 4]K = 4</code></pre><p>the function should return [1, 2, 3, 4]</p><p>Assume that:</p><p>N and K are integers within the range [0..100];<br>each element of array A is an integer within the range [−1,000..1,000].<br>In your solution, focus on correctness. The performance of your solution will not be the focus of the assessment.</p></blockquote><hr><p>문제해설 : 배열 A는 N개의 integers로 구성되어 있다. 배열의 Rotation은 각 배열의 요소가 한개씩 오른쪽 index로 이동하는 것을 의미한다. 그리고 마지막 index의 요소는 첫번째 index 요소로 이동한다.<br>예를 들면 A = [3,8,9,7,6] 은 [6,3,8,9,7]로 Rotation 된다.<br>이 문제의 목표는 배열 A가 K번 rotate하는 결과값을 리턴한다.</p><p>주의사항 :</p><ul><li>N과 K는 [0, 100]의 범위를 가지는 integer이다.</li><li>각 A배열의 요소emfdms -1000 ~ 1000의 범위의 integer로 구성되어져 있다.</li></ul><h2 id="답안-해설"><a href="#답안-해설" class="headerlink" title="답안 해설"></a>답안 해설</h2><p>작성코드 :<br><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">js</li></ul></figcaption><div class="tabs-content"><figure class="highlight js" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">A, K</span>) </span>{</span><br><span class="line">  <span class="keyword">while</span>(K &gt; <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">var</span> last = A[A.length<span class="number">-1</span>];</span><br><span class="line">    A.unshift(last);</span><br><span class="line">    A.pop();</span><br><span class="line">    K--;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> A;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure></p><blockquote><p>주어진 Rotation횟수 K는 0 ~ 100까지의 수이므로 while 반복문 내에서 배열의 요소들을 계속해서 Rotate 할 수 있다.<br>while문 내부에서는 last에 배열의 마지막 인덱스값을 할당하고 unshift() 함수를 통해 배열의 맨 앞으로 보낸다.<br>그 후 배열의 마지막 요소를 pop() 함수를 통해 제거한다.<br>마지막으로 K를 감소시킨다.<br>이 함수는 주어진 배열 A에서 K만큼만 배열의 요소를 움직이므로 시간복잡도는 O(N)이다.</p></blockquote><h2 id="실행결과"><a href="#실행결과" class="headerlink" title="실행결과"></a>실행결과</h2><div class="figure center" style="width:100%;"><a class="fancybox" href="codility-lesson-2-array-cyclerotation.png" title="Lesson 2 CycleRotation Codility Result" data-caption="Lesson 2 CycleRotation Codility Result" data-fancybox="codility"><img class="fig-img" src="codility-lesson-2-array-cyclerotation.png" style="width:100%;height:100%;" alt="Lesson 2 CycleRotation Codility Result"></a><span class="caption">Lesson 2 CycleRotation Codility Result</span></div><div style="clear:both;"></div>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Codility의 두번째 lesson이다. 이번 lesson에선 배열에 관한 문제들을 다룬다.&lt;br&gt;
    
    </summary>
    
      <category term="코딩테스트" scheme="http://ksw1652.github.io/categories/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
    
      <category term="이직" scheme="http://ksw1652.github.io/tags/%EC%9D%B4%EC%A7%81/"/>
    
      <category term="코딜리티" scheme="http://ksw1652.github.io/tags/%EC%BD%94%EB%94%9C%EB%A6%AC%ED%8B%B0/"/>
    
      <category term="코테" scheme="http://ksw1652.github.io/tags/%EC%BD%94%ED%85%8C/"/>
    
  </entry>
  
  <entry>
    <title>Front-End Interview Question - Javascript Question</title>
    <link href="http://ksw1652.github.io/2018/08/28/front-end-interview-javascript-question/"/>
    <id>http://ksw1652.github.io/2018/08/28/front-end-interview-javascript-question/</id>
    <published>2018-08-27T18:16:00.000Z</published>
    <updated>2019-03-15T06:59:38.137Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><blockquote><p>event delegation에 관해 설명해주세요.</p></blockquote><p>이벤트 위임(Event Delegation)은 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법입니다.</p><p>예제를 통해 살펴보면</p><script async src="//jsfiddle.net/sungwooKIM/nu02rhts/embed/js,html,result/"></script><p>#parent Element에 자식으로 #child-* Element가 다수 있습니다. 이때 각각의 자식 요소에 이벤트 리스너를 바인딩합니다.<br>자식 Element의 갯수만큼 이벤트 리스너는 바인딩 되고 자식 Element의 갯수가 늘어나게 된다면 이벤트 리스너를 바인딩하는 코드 역시 늘어나게 될 것입니다.<br>이러한 코드의 중복사용을 막기 위하여 Event Delegation을 이용합니다.<br>이때 Event Bubbling의 원리를 이용해 자식 Element에서 이벤트가 발생하게 되면 부모 Element로 점점 전파되어 document레벨까지 도달하게 됩니다.<br>즉 모든 자식 Element에게 이벤트를 바인딩 할 필요없이 부모 Element에게만 이벤트 리스너를 바인딩하면 된다는 뜻이죠</p><p>바뀐 코드를 살펴보겠습니다.</p><script async src="//jsfiddle.net/sungwooKIM/punozqsd/embed/js,html,result/"></script><p>부모 Element에 이벤트 리스너를 바인딩 한 후 전달받은 e 인자를 통해 Element 타겟을 검사합니다.<br>e.target.nodeName으로 Elemnt가 li인 요소만 이벤트를 발생하도록 합니다.<br>이를 통해 모든 자식 Element에서 이벤트 리스너를 바인딩 할 필요 없이 부모 Element에게 이벤트 위임(Event Delegation)되었습니다.</p><blockquote><p>this는 JavaScript에서 어떻게 작동하는지 설명해주세요.</p></blockquote><p>참조 : <a href="https://poiemaweb.com/js-this" target="_blank" rel="noopener">함수 호출 패턴에 따라 결정되는 this</a></p><blockquote><p>prototype 기반 상속은 어떻게 하는지 설명해주세요.</p></blockquote><p>참조 : <a href="/2018/07/30/javascript-prototype/" title="Javascript Prototype">Javascript Prototype</a></p><blockquote><p>AMD와 CommonJS는 무엇이고, 이것들에 대해 어떻게 생각하시나요?</p></blockquote><p>두 가지 모두 ES2015 가 등장할 때까지 JavaScript 에 기본적으로 존재하지 않는 모듈 시스템을 구현하는 방법입니다.CommonJS 는 동기식인 반면 AMD (Asynchronous Module Definition - 비동기식 모듈 정의)는 분명히 비동기식입니다.CommonJS 는 서버-사이드 개발을 염두에 두고 설계되었으며 AMD 는 모듈의 비동기 로딩을 지원하므로 브라우저용으로 더 많이 사용됩니다.</p><p>AMD 은 구문이 매우 장황하고 CommonJS 은 다른 언어로 된 import 문을 작성하는 스타일에 더 가깝습니다. 대부분의 경우 AMD 를 필요로 하지 않습니다. 모든 JavaScript 를 연결된 하나의 번들 파일로 제공하면 비동기 로딩 속성의 이점을 누릴 수 없기 때문입니다. 또한 CommonJS 구문은 모듈 작성의 노드 스타일에 가깝고 클라이언트-사이드과 서버-사이드 JavaScript 개발 사이를 전환할 때 문맥 전환 오버 헤드가 적습니다.</p><p>ES2015 모듈이 동기식 및 비동기식 로딩을 모두 지원하는 것이 반가운 것은 마침내 하나의 접근 방식만 고수할 수 있다는 점입니다. 브라우저와 노드에서 완전히 작동되지는 않았지만 언제나 트랜스파일러를 사용하여 코드를 변환할 수 있습니다.</p><a href="https://github.com/yangshun/front-end-interview-handbook/tree/master/Translations/Korean" target="_blank" rel="noopener">참고 : 프론트엔드 인터뷰 핸드북</a><blockquote><p>다음 코드가 즉시 호출 함수 표현식(IIFE)로 동작하지 않는 이유에 관해서 설명해보세요:</p><ul><li>function foo(){ }();</li><li>IIFE로 만들기 위해서는 어떻게 해야 하나요?</li></ul></blockquote><p>즉시실행함수의 경우 (function() { })() 와 같은 형태로 작성되어야 합니다.<br>함수명은 필요 없으며 function keyword 앞에 괄호와 중괄호 뒤 괄호가 필요합니다.<br>또한 일반적인 함수 호출과는 다르게 함수를 만들고 호출할 필요가 없으며 코드만 넣어주면 됩니다.</p><blockquote><p>null과 unedefined 그리고 undeclared의 차이점은 무엇인가요?</p><ul><li>두개를 구분하기 위해서는 어떻게 하면 될까요?</li></ul></blockquote><p><strong>null</strong> : javascript 에서의 null은 값이 아닌 객체참조의 연결을 해지하는 것을 말합니다.<br>즉 참조값이 존재 하지 않기 때문에 비어있는 값을 가진 변수가 되는 것입니다.</p><p><strong>undefined : </strong> 선언만 되어지고 특정 값이 할당되지 않는 경우 javascript 엔진에 의해 자동으로 할당되는 값입니다. 특별히 할당된 값이 없는 경우 일반적인 언어처럼 null 이 아니고 undefiend 가 할당 됩니다.<br>또한 객체가 소유하지 않은 프로퍼티에 접근하게 될 경우에도 undefined 가 반환됩니다.</p><p><strong>undeclared : </strong> undeclared 변수란 선언하지 않고도 사용 가능한 변수 입니다.<br>예를 들어 <code>testVar = ‘hello world’;</code> 와 같이 var keyword를 사용하지 않고 선언된 변수 입니다.<br>scope 개념에서 보았을 때 유효범위를 지정하지 않았기 때문에 글로벌 변수로 생성 됩니다.</p><p><strong>null과 undefiend 비교 : </strong> javascript 엔진은 절대로 변수에 null을 할당하지 않습니다.<br>null은 프로그래머가 할당하는 것이며 변수의 참조링크를 끊기 위해 사용합니다.<br>반면 undefined는 javascript 엔진에 의해 자동으로 할당됩니다.</p><blockquote><p>클로져(Closure)는 무엇이며, 어떻게/왜 사용하는지 설명해주세요.</p></blockquote><p>클로저(closure)는 내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것을 가르킵니다.<br>클로저는 자바스크립트를 이용한 고난이도의 테크닉을 구사하는데 필수적인 개념으로 활용됩니다.<br>클로저란 내부함수가 외부함수의 지역변수에 접근 할 수 있고, 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 않는 특성을 의미합니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>클로저 예제</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myName</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'shawn'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = myName();</span><br><span class="line">test();</span><br></pre></td></tr></tbody></table></figure></div></figure><blockquote><p>익명함수(anonymous functions)는 주로 어떤 상황에서 사용하나요?</p></blockquote><p>익명함수의 사용은 함수 선언이 아닌 함수표현식을 이용하는 방법입니다.<br>이는 곧 람다함수(함수 리터럴을 변수에 할당하는 방식)와 즉시실행구문을 만들어 낼수 있다는 의미이며,<br>이처럼 즉시실행 구문을 사용하면 javascript 가 유효범위를 선언 할 수 없다고 해도 강제적으로 private 변수를 만들어 내는 것이 가능 합니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>익명함수 예제</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i 라는 변수는 실행 시점에서만 사용되면 외부에서 접근 할수 없다.</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">   <span class="keyword">var</span> i  = <span class="string">'hello world'</span>;</span><br><span class="line">})();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">&gt; error</span><br></pre></td></tr></tbody></table></figure></div></figure><p>즉 익명함수는 동적으로 할당되는 유효범위를 가지기 때문에 javascript 내에서 강제적인 유효범위 설정을 하는 경우 사용되게 됩니다.</p><blockquote><p>당신의 코드를 어떻게 구성하는지? (모듈 패턴, 전통적 상속)</p></blockquote><p>모듈 패턴으로 코드를 작성합니다. ES6문법에 따라 export, import를 사용하여 모듈화 합니다.</p><blockquote><p>호스트 객체(Host Objects)와 네이티브 객체(Native Objects)의 차이점은 무엇인가요?</p></blockquote><p><strong>네이티브 객체(Native Object) :</strong> 네이티브 객체는 브라우저 혹은 구동 엔진에 내장되어 있는 객체를 말합니다.<br>네이티브 객체는 built-in 객체와 달리 자바스크립트 엔진이 구성하고 있는 기본객체라고 하기보단 브라우저 혹은 사용되는 자바스크립트 엔진에 영향을 많이 받게 됩니다.<br>B.O.M 이라는 브라우저객체 모델과 D.O.M 이라는 문서 객체 모델이 네이티브 객체에 포함되는데 이 객체의 사용성이 이를 구현한 구동엔진에 따라 각기 다르게 존재하는 경우가 있기 때문에 크로스 브라우징에 문제를 발생시키기도 합니다.</p><p><strong>호스트 객체(Host Object) :</strong> 호스트 객체는 빌트인 객체와 네이티브객체에 포함되지 않은 사용자에 의해 생성된 객체를 의미합니다.<br>자바스크립트 엔진은 빌트인 객체와 네이티브 객체를 구성한 이후 호스트객체를 해석하게 됩니다.</p><blockquote><p>다음 코드의 차이점은 무엇인가요?</p><ul><li>function Person(){}</li><li>var person = Person()</li><li>var person = new Person()</li></ul></blockquote><p><strong>1. function Person() {}</strong><br>함수를 선언하지만 실행하지는 않습니다.<br>대개 중괄호 사이에 코드가 있습니다.</p><p><strong>2. var person = Person()</strong><br>변수 (person)을 선언하고, 함수 (person)를 호출하며, person의 값을 함수의 반환 값으로 설정합니다.</p><p><strong>3. var person = new Person ()</strong><br>Person 함수를 기반으로 객체의 새 인스턴스를 만듭니다. 따라서 변수 (person)는 이제 문자열이나 숫자가 아닌 Object입니다.</p><blockquote><p>.call과 .apply의 차이점은 무엇인가요?</p></blockquote><p>둘 다 Context를 조정하기 위한 함수입니다.<br>함수 안에서 this 를 사용할 때 대체 this가 어디냐를 조정하는 것인데, 기본적으로 브라우저에서는 this는 window 객체를 가리킵니다.<br>Object의 메서드는 해당 객체를 가리키게 되고, 객체의 메서드만 따로 변수로 참조하는 경우엔 이 Context가 window로 되어 버립니다.<br>따라서 Context를 조정해야 할 때 call과 apply를 사용합니다.</p><p>이 둘의 차이점은 paramater에 있습니다. call의 경우 전달인자를 하나하나씩 보내지만 .apply의경우 배열의 형태로 전달합니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>call and apply Example</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.call Example</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">firstName, middleName, lastName</span>)</span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My Name is "</span> + firstName + <span class="string">' '</span> + middleName + <span class="string">' '</span> + lastName);</span><br><span class="line">}</span><br><span class="line">getName.call(<span class="keyword">this</span>, <span class="string">'sungwoo'</span>, <span class="string">'shawn'</span>, <span class="string">'KIM'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//.apply Example</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">firstName, middleName, lastName</span>)</span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My Name is "</span> + firstName + <span class="string">' '</span> + middleName + <span class="string">' '</span> + lastName);</span><br><span class="line">}</span><br><span class="line">getName.apply(<span class="keyword">this</span>, [<span class="string">'sungwoo'</span>, <span class="string">'shawn'</span>, <span class="string">'KIM'</span>]);</span><br></pre></td></tr></tbody></table></figure></div></figure><blockquote><p>Function.prototype.bind을 설명하세요.</p></blockquote><p>bind() 메소드는 호출될 때 그 this 키워드를 제공된 값으로 설정하고 새로운 함수가 호출될 때 제공되는 주어진 순서의 선행 인수가 있는 새로운 함수를 생성합니다.</p><blockquote><p>document.write()는 언제 사용하나요?</p></blockquote><p>디버깅이나 화면에 출력해야하는 상황에 사용합니다.</p><blockquote><p>UA 문자열을 이용하여 기능 검출(feature detection)과 기능 추론(feature inference)의 차이점을 설명하세요.</p></blockquote><p>기능 검출은 브라우저에게 기능 X가 존재하는지 묻습니다.<br>예를 들어 웹 어플리케이션에서 localStorage를 사용한다고 가정하였을때</p><p><code>if(&#39;localStorage&#39; in window)</code></p><p>위와 같이 localStorage가 존재하는지 묻습니다.<br>반면에 기능 추론은 기능 ‘localStorage’가 존재한다면 ‘sessionStorage’도 존재한다고 추론해 내는 것입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">'localStorage'</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">   <span class="built_in">window</span>.sessionStorage.setItem(<span class="string">"this-should-exist-too"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 방식은 오래된 방식이고 UA String은 단순히 문자열일 뿐이기 때문에 기능 검증을 위한 방법으로 사용하지 않는 것이 좋습니다.</p><blockquote><p>AJAX에 관해 가능한 한 자세히 설명하세요.</p></blockquote><p>AJAX란 비동기 자바스크립트와 XML (Asynchronous JavaScript And XML)을 말합니다.<br>간단히 말하면, 서버와 통신하기 위해 XMLHttpRequest 객체를 사용하는 것을 말합니다.<br>JSON, XML, HTML 그리고 일반 텍스트 형식 등을 포함한 다양한 포맷을 주고 받을 수 있습니다.<br>AJAX의 강력한 특징은 페이지 전체를 리프레쉬 하지 않고서도 수행 되는 “비동기성”입니다.<br>이러한 비동기성을 통해 사용자의 Event가 있으면 전체 페이지가 아닌 일부분만을 업데이트 할 수 있게 해줍니다.<br>대부분의 Morden Front-End Framework은 AJAX를 기반으로한 모듈로 서버와 통신합니다.</p><blockquote><p>AJAX를 사용했을 때의 장단점에 대해 설명해주세요.</p></blockquote><p><strong>장점</strong></p><ol><li>웹페이지 전체를 다시 로딩하지 않아도 됩니다. 원하는 데이터만 서버로부터 가져와 바인딩합니다.</li><li>서버처리를 기다리지 않고 비동기 요청이 가능합니다.</li><li>수신하는 데이터의 양을 줄일 수 있고, 클라이언트에게 처리를 위임 할 수 있습니다.</li></ol><p><strong>단점</strong></p><ol><li>Ajax를 사용할 수 없는 브라우저에 대한 문제가 있습니다.(요즘에는 잘 못 본듯…)</li><li>Http클라이언트의 기능이 한정되어 있습니다.</li><li>페이지의 이동없는 통신으로 인한 보안상의 문제가 있습니다.</li><li>지원하는 Charset이 한정되어 있습니다.</li><li>요청을 남발하면 서버의 부하가 늘어날 수 있습니다.</li><li>동일 출처 정책(CORS issue)로 인해 다른 도메인과 통신이 불가능합니다.</li></ol><blockquote><p>JSONP가 어떻게 동작 되는지 설명하세요. (그리고 AJAX와 어떻게 다른지 설명하세요.)</p></blockquote><p>JSONP는 AJAX와는 다르게 데이터를 요청하는 것이 아닌 <code>&lt;script&gt;</code>를 호출하는 방식으로 구현됩니다.<br>AJAX의 통신 방식은 동일 출처 원칙(Same Origin Policy)에 의해 동일한 도메인에서만 호출이 가능한데,<br>다른 도메인에서 호출할 경우 이 동일 출처 원칙에 의해 데이터를 가져올 수 없게 되어있습니다.<br>그러나 <code>&lt;script&gt;</code>태그의 경우 동일 출처 원칙을 따르지 않아도 되기 때문에 이 원리를 바탕으로 JSONP방식을 사용하는 것입니다.</p><p>동작 방식은 데이터를 요청할 페이지에, 데이터를 받아 처리할 콜백 함수를 먼저 준비해놓습니다.<br>그 후에 <code>&lt;script&gt;</code> 요소를 생성하여, 데이터 요청을 합니다.<br>데이터 요청을 받은 페이지에서는 콜백 함수를 실행하는 스크립트를 출력합니다.<br>이 때 callback 함수의 인자에는 요청받은 데이터가 들어가게 됩니다.<br>여기서 주의 할 점은 JSONP 방식의 경우 GET 메서드만 호출 가능하다는 점이다.</p><blockquote><p>“호이스팅(Hoisting)”에 대해서 설명하세요.</p></blockquote><p>Hoisting이란 사전적 의미로 <code>끌어올려지다</code>라는 뜻이며 범위(scope)에 따라 변수의 선언과 할당이 분리 되는 것을 의미합니다.<br>즉 변수가 함수 내에서 선언되었을 경우 함수의 최상위로, 함수 바깥에서 선언되었을 경우 전역 Context의 최상위로 변경됩니다.</p><p>호이스팅에서 주의할 점은 호이스트 되었을 때 함수선언은 변수선언을 덮어씁니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>호이스팅 예제(함수선언 > 변수선언)</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myName</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'shwan'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myName) <span class="comment">// 'shawn'</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>위 예제 처럼 변수와 함수의 이름이 같은경우 함수의 우선순위가 높기 때문에 함수선언이 변수선언을 덮어씁니다.<br>반면에 아래와 같이 변수에 값이 할당 된 경우 변수선언이 함수선언을 덮어씁니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>호이스팅 예제(변수선언 > 함수선언)</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="string">'sungwooKIM'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myName</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'shwan'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myName) <span class="comment">// 'sungwooKIM'</span></span><br></pre></td></tr></tbody></table></figure></div></figure><blockquote><p>이벤트 버블링(Event Bubbling)에 대해서 설명하세요.</p></blockquote><p>하위에서 상위 요소로 이벤트를 전파하는 방식을 이벤트 버블링(Event Bubbling)이라고 합니다.</p><blockquote><p>“속성(Attribute)”와 “요소(property)”의 차이가 무엇인가요?</p></blockquote><p><strong>attribute : </strong><br>Attributes는 HTML 요소의 추가적인 정보를 전달하고 이름=”값” 이렇게 쌍으로서 표현됩니다.<br>예를 들어 <code>&lt;div class=&quot;my-class&quot;&gt;&lt;/div&gt;</code> 를 보면 <code>class</code>라는 attribute에 ‘my-class’라는 값이 할당 됩니다.</p><p><strong>property : </strong><br>Property는 attribute에 대한 HTML DOM 트리 내부에서의 표현입니다.<br>DOM안에서의 표현이기 때문에 위 예제에서 property는 <code>className</code>이며 값으로 ‘my-class’를 가지게 됩니다.</p><p>둘을 비교하였을 때 Attributes는 HTML 텍스트 문서에 있는 것이고 properties는 HTML DOM 트리에 있는 것입니다. attribute는 변하지 않고 초기 (default)값을 전달한다는 것은 의미하며 반면에 HTML properties는 변할 수 있습니다. 예를 들어 사용자가 체크박스를 체크했거나 input 박스에 텍스트를 넣었거나 JavaScript로 값을 변경하면 property의 값은 변하게 됩니다.</p><blockquote><p>내장된 JavaScript 객체를 확장하는 것이 좋지 않은 이유는 무엇인가요?</p></blockquote><p>내장객체를 확장하는 방식은 객체의 prototype에 속성 또는 함수를 추가하는 것을 의미합니다. 이는 겉으로는 편리해 보일지 몰라도 실제로는 위험한 방법입니다.<br>만약 Array 내장 객체를 확장 한 후, Array.prototype을 확장하는 라이브러리를 사용하였을 때 예기치 못한 결과를 초래 할 수도 있습니다.</p><blockquote><p>document load event와 DOMContentLoaded event의 차이점은 무엇인가요?</p></blockquote><p><strong>DOMContentLoaded event :</strong><br>HTML 이 모두 로드되고, DOM 트리가 완성되었지만, 외부 리소스(img etc) 가 아직 로드되어지지 않았을 때 DOM이 준비 상태이기 때문에, DOM 노드를 제어할 수 있습니다.</p><p><strong>document load event :</strong><br>브라우저에 모든 리소스(img, style, script, etc) 가 로드되었을 때<br>모든 리소스가 로드된 시점이기에, image 사이즈와 같은 것들을 얻을 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOMContentLoaded == window.onDomReady()</span><br><span class="line">Load == window.onLoad()</span><br></pre></td></tr></table></figure><blockquote><p>==와 ===의 차이점은 무엇인가요?</p></blockquote><p><code>==</code>은 비교 구문에서 두 변수의 값만을 비교합니다. javascript의 변수는 타 언어에 비해 유연해서 <code>1 == &#39;1&#39;</code>도 true를 반환합니다.<br>이러한 유연함 때문에 값과 더불어 타입까지 비교할때 <code>===</code>를 사용합니다.</p><blockquote><p>JavaScript의 “동일출처정책(the same-origin policy)”에 대해서 설명하세요.</p></blockquote><p>same origin policy는 한 출처(origin 또는 도메인)에서 로드된 문서나 다른 출처 자원과 상호작용하지 못하도록 제약합니다. 이 정책으로 CORS 크로스 도메인 이슈 (No ‘Access-Control-Allow-Origin’ header is present on the requested resource) 발생하게되는데, 주로 프론트 코드에서 AJAX요청시 자주 발생합니다. BackEnd와 FrontEnd의 출처(Domain)이 다르기 때문입니다.<br>여러가지 해결 방법이 있지만 대표적으로는 Front에서 JSONP를 사용하거나 BackEnd에서 모든 요청을 허용하도록 설정 한 후 인증을 거쳐 사용하도록 하는 방법이 있습니다.</p><blockquote><p>다음 코드를 동작하게 만드세요.</p><ul><li>duplicate([1,2,3,4,5]); // [1,2,3,4,5,1,2,3,4,5]</li></ul></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><span>duplicate example</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">duplicate</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> arr.concat(arr);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">duplicate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br></pre></td></tr></tbody></table></figure></div></figure><blockquote><p>삼항식(Ternary statement)을 사용하는 이유는 무엇이고, 그것을 표현하기 위한 연산자 단어는 무엇인가요?</p></blockquote><p>if의 축약형으로 사용하며 코드가 직관적이고 간결해지는 이점이 있습니다.<br>주로 아래와 같이 사용합니다.</p><p><code>condition ? expr1 : expr2</code></p><blockquote><p><code>use strict;</code> 은 무엇이고, 사용했을 때 장단점에 관해서 설명해주세요.</p></blockquote><p><code>use strict;</code> 은 ECMAScript 버전 5에서 새로 추가되었습니다.<br>이전 버전의 JavaScript에서는 무시되며 strict mode를 사용하기위해 표시합니다.<br>strict mode에서는 선언되지 않은 변수를 사용할 수 없습니다.</p><p>예를 들어 아래의 예제에서는 에러가 발생합니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>strict mode example</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">myFunction();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>{</span><br><span class="line">    y = <span class="number">3.14</span>;   <span class="comment">// This will also cause an error because y is not declared</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><blockquote><p>100번 반복되는 반복문이 있습니다. 3의 배수일 때는 fizz, 5의 배수일 때는 buzz, 3과 5의 공배수일 때는 fizzbuzz가 출력되는 코드를 작성해보세요.</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><span>strict mode example</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fizzbuzz</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;= <span class="number">100</span>; i++) {</span><br><span class="line">    <span class="keyword">if</span>((i%<span class="number">3</span> === <span class="number">0</span>) &amp;&amp; (i%<span class="number">5</span> === <span class="number">0</span>)) {</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Number is '</span> + i + <span class="string">'fizzbuzz'</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span> === <span class="number">0</span>) {</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Number is '</span> + i + <span class="string">'fizz'</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">5</span> === <span class="number">0</span>) {</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Number is '</span> + i + <span class="string">'buzz'</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fizzbuzz();</span><br></pre></td></tr></tbody></table></figure></div></figure><blockquote><p>전역 scope를 사용했을 때 장단점에 관해 설명해주세요.</p></blockquote><p>전역 scope를 사용하였을 때 변수의 scope를 생각하지 않고 빠르게 코딩할 수 있는 장점이 있지만 이렇게 사용하지 않는 편이 좋습니다.<br>전역 scope를 남발할 경우 변수 또는 함수와 네임스페이스로 인한 충돌이 발생할 수 있기 때문에 로컬 scope을 사용하여 모듈화하고 의존성을 최소화 해야 합니다.</p><blockquote><p>때때로 load event를 사용하는 이유에 관해 설명해주세요. 또 단점이 있다면 대안에 대해서도 설명해주세요.</p></blockquote><ul><li>load event는 외부 리소스까지 모두 로드한 시점에 동작 할 코드가 들어갑니다.<br>예를 들면 로드한 이미지의 사이즈를 가져오는 경우가 있습니다.</li><li>load event의 단점은 <span class="highlight-text green">한번만 실행되기 때문에 다른 JS라이브러리에서 load event가 구현되어있을 경우 코드가 복잡해 질 수 있다는 점 </span>과<span class="highlight-text blue">모든 리소스를 다운 받은 후 동작하기 때문에 사용자 입장에서 느릴 수 있다는 점 </span> 입니다.<br>이에 대한 대안으로 jquery의 ready함수나 FE Framework의 라이프사이클 훅(lifecycle hook)을 활용 할 수 있습니다.</li></ul><blockquote><p>SPA에서 SEO에 유리하도록 만들기 위한 방법에 대해 설명해주세요.</p></blockquote><p>최근 SPA로 제작되는 웹 어플리케이션이 많아짐에 따라 SEO 최적화가 화두가 되었습니다.<br>검색엔진마다 다르겠지만 구글을 기준으로 SEO를 최적화 할 경우 각각 구현한 SPA마다 최적화의 방식이 다릅니다.<br>Angular 4는 Angular Universal을 사용하여 서버에서 HTML을 미리 렌더링하여 클라이언트에 전송합니다.<br>서버 측 렌더링을 통해 검색봇이 페이지를 크롤링 할 때 구식 HTML이 수신되도록 처리합니다.</p><blockquote><p>Promise를 사용해 본 경험이 있나요?</p></blockquote><p>네, 자주 사용합니다.<br>최근에는 Promise와 더불어 async/await를 사용합니다.</p><blockquote><p>Promise가 콜백 대비 장/단점은 무엇인지 설명해주세요.</p></blockquote><p><strong>장점</strong></p><ul><li>콜백 헬을 벗어날 수 있다는점.</li><li>체이닝을 통한 연속적인 코드 작성 가능</li><li>Promise.all과 같은 병렬 비동기 코드 작성 가능</li><li>라이브러리를 추가(bluebird)하여 .spread(), .finally()와 같은 코드도 사용할 수 있다는 점</li></ul><p><strong>단점</strong></p><ul><li>ES2015를 지원하지 않는 이전 브라우저에서 이를 사용하기 위해서는 polyfill을 로드해야 합니다.</li></ul><blockquote><p>JavaScript의 작동방식의 장단점에 관해 설명해주세요.</p></blockquote><p><strong>장점</strong></p><ul><li>페이지 리로드 없이 바로 화면에 적용이 가능합니다. 이로 인해 사용자에게 더 빠른 속도감을 제공 할 수 있습니다.</li><li>싱글 스레드/비동기로 동작하기 때문에 페이지 로드를 기다리지 않아도 됩니다.</li></ul><p><strong>단점</strong></p><ul><li>싱글스레드/비동기로 동작하기 때문에 완료시점에 대한 Timeing을 catch하기 어렵습니다.<br>(그래서 Promise나 RxJS, async/await를 주로 사용합니다)</li></ul><blockquote><p>JavaScript를 디버깅할 때 사용하는 도구가 있으면 설명해주세요.</p></blockquote><ul><li>Chrome DevTools</li><li>Safari Developer Mode</li><li>vue-devtools</li><li>WebStorm Debugger</li><li>console.log()</li><li>window.alert() –&gt; debugger를 사용하지 못할 때, console.log()를 사용하지 못할때 사용합니다.</li></ul><blockquote><p>객체 안의 속성과 배열의 아이템을 순회할 때 사용하는 문법에 관해 설명해주세요.</p></blockquote><p><strong>오브젝트의 경우:</strong></p><ul><li>for 반복문 - for (var property in obj) { console.log(property); }. 그러나 이것은 상속된 속성도 반복되며, 사용하기전에 obj.hasOwnProperty(property) 체크를 추가해야 합니다.</li><li>Object.keys() - Object.keys(obj).forEach(function (property) { … }). Object.keys ()는 전달하는 객체의 열거 가능한 모든 속성을 나열하는 정적 메서드입니다.</li><li>Object.getOwnPropertyNames() - Object.getOwnPropertyNames(obj).forEach(function (property) { … }). Object.getOwnPropertyNames()는 전달하는 객체의 열거 가능한 속성과 열거되지 않는 모든 속성을 나열하는 정적 메서드입니다.</li></ul><p><strong>배열의 경우:</strong></p><ul><li>for 반복문 - for (var i = 0; i &lt; arr.length; i++). 여기에 있는 일반적인 함정은 ‘var’이 함수 범위에 있고 블록 범위가 아니며 대부분 블록 범위의 반복자 변수를 원할 것이라는 점입니다. ES2015에는 블록 범위가 있는 let을 도입하고 대신 사용할 것을 권장합니다. 그래서 다음과 같이 됩니다. for (let i = 0; i &lt; arr.length; i++).</li><li>forEach - arr.forEach(function (el, index) { … }). 필요한 모든 것이 배열 요소라면 index를 사용할 필요가 없기 때문에 이 구조가 더 편리 할 수 ​​있습니다. 또한 every과 some 메서드를 이용하여 반복을 일찍 끝낼 수 있습니다.</li></ul><p>최근에는 주로 lodash 라이브러리를 사용합니다. 위 케이스의 대부분의 반복을 제공하며 속도 또한 빠릅니다.</p><a href="https://github.com/yangshun/front-end-interview-handbook/tree/master/Translations/Korean" target="_blank" rel="noopener">참고 : 프론트엔드 인터뷰 핸드북</a><blockquote><p>mutable object와 immutable object에 관해 설명해주세요.</p></blockquote><p>Javascript의 기본 자료형(primitive data type)은 변경 불가능한 값(immutable value) 입니다.</p><ul><li>Boolean</li><li>null</li><li>undefined</li><li>Number</li><li>String</li><li>Symbol (New in ECMAScript 6)</li></ul><p>기본 자료형 이외의 모든 값은 객체(Object) 타입이며 객체 타입은 변경 가능한 값(mutable value) 입니다. 즉, 객체는 새로운 값을 다시 만들 필요없이 직접 변경이 가능합니다.<br>C 언어와는 다르게 Javascript의 문자열은 변경 불가능한 값(immutable value) 입니다. 이런 값을 “primitive values” 라 합니다.<br>(변경이 불가능하다는 뜻은 메모리 영역에서의 변경이 불가능하다는 의미이며 재할당은 가능합니다)</p><blockquote><p>동기방식과 비동기 방식 함수의 차이에 관해서 설명해주세요.</p></blockquote><p>동기방식은 현재의 명령문이 컴파일되고 에러없이 실행되기 전까지 다음 명령문을 실행하지 않습니다.<br>반면 비동기 방식은 현재 명령문의 완료와 상관 없이 다음 명령문을 실행합니다.<br>비동기 방식은 일반적으로 명령문이 완료되고 호출스택이 비어있을 때 콜백을 호출합니다.</p><blockquote><p>event loop이란 무엇인가요?</p><ul><li>call stack과 task queue에 관해 설명해주세요.</li></ul></blockquote><p>브라우저는 단일 쓰레드(single-thread)에서 이벤트 드리븐(event-driven) 방식으로 동작합니다.<br>단일 쓰레드는 쓰레드가 하나뿐이라는 의미이며 이말은 곧 하나의 작업(task)만을 처리할 수 있다는 것을 의미합니다.<br>하지만 실제로 동작하는 웹 애플리케이션은 많은 task가 동시에 처리되는 것처럼 느껴집니다.<br>이처럼 자바스크립트의 동시성(Concurrency)을 지원하는 것이 바로 이벤트 루프(Event Loop)입니다.</p><p>브라우저의 환경을 그림으로 표현하면 아래와 같습니다.</p><div class="figure center" style="width:100%;"><a class="fancybox" href="event-loop.png" title="javascript event loop" data-caption="javascript event loop" data-fancybox="javascript"><img class="fig-img" src="event-loop.png" style="width:100%;height:100%;" alt="javascript event loop"></a><span class="caption">javascript event loop</span></div><div style="clear:both;"></div><p>구글의 V8을 비롯한 대부분의 자바스크립트 엔진은 크게 2개의 영역으로 나뉩니다.</p><p><strong>Call Stack(호출 스택)</strong><br>작업이 요청되면(함수가 호출되면) 요청된 작업은 순차적으로 Call Stack에 쌓이게 되고 순차적으로 실행됩니다. 자바스크립트는 단 하나의 Call Stack을 사용하기 때문에 해당 task가 종료하기 전까지는 다른 어떤 task도 수행될 수 없습니다.</p><p><strong>Heap</strong><br>동적으로 생성된 객체 인스턴스가 할당되는 영역입니다.<br>이와 같이 자바스크립트 엔진은 단순히 작업이 요청되면 Call Stack을 사용하여 요청된 작업을 순차적으로 실행할 뿐입니다. 앞에서 언급한 동시성(Concurrency)을 지원하기 위해 필요한 비동기 요청(이벤트를 포함) 처리는 자바스크립트 엔진을 구동하는 환경 즉 브라우저(또는 Node.js)가 담당합니다.</p><p><strong>Event Queue(Task Queue)</strong><br>비동기 처리 함수의 콜백 함수, 비동기식 이벤트 핸들러, Timer 함수(setTimeout(), setInterval())의 콜백 함수가 보관되는 영역으로 이벤트 루프(Event Loop)에 의해 특정 시점(Call Stack이 비어졌을 때)에 순차적으로 Call Stack으로 이동되어 실행됩니다.</p><p><strong>Event Loop(이벤트 루프)</strong><br>Call Stack 내에서 현재 실행중인 task가 있는지 그리고 Event Queue에 task가 있는지 반복하여 확인합니다. 만약 Call Stack이 비어있다면 Event Queue 내의 task가 Call Stack으로 이동하고 실행됩니다.</p><blockquote><p>function foo() {}와 var foo = function() {}에서 foo 의 차이가 무엇인지 설명해보세요.</p></blockquote><p>전자는 함수선언(Function Declarations)이며 후자는 함수표현(Function Expressions)입니다.<br>함수 선언식은 호이스팅에 영향을 받지만, 함수 표현식은 호이스팅에 영향을 받지 않습니다.<br>함수 선언식은 코드를 구현한 위치와 관계없이 자바스크립트의 특징인 호이스팅에 따라 브라우저가 자바스크립트를 해석할 때 맨 위로 끌어 올려집니다.</p><p>예를 들어, 아래의 코드를 실행할 때</p><figure class="codeblock codeblock--tabbed"><figcaption><span>function declarations and function expressions example</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실행 전</span></span><br><span class="line">logMessage();</span><br><span class="line">sumNumbers();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logMessage</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'worked'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sumNumbers = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span> + <span class="number">20</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></div></figure><p>호이스팅에 의해 자바스크립트 해석기는 코드를 아래와 같이 인식합니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>function declarations and function expressions example</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실행 시</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logMessage</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'worked'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sumNumbers;</span><br><span class="line"></span><br><span class="line">logMessage(); <span class="comment">// 'worked'</span></span><br><span class="line">sumNumbers(); <span class="comment">// Uncaught TypeError: sumNumbers is not a function</span></span><br><span class="line"></span><br><span class="line">sumNumbers = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span> + <span class="number">20</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></div></figure><p>함수 표현식 sumNumbers 에서 var 도 호이스팅이 적용되어 위치가 상단으로 끌어올려졌습니다.<br>하지만 실제 sumNumbers 에 할당될 function 로직은 호출된 이후에 선언되므로, sumNumbers 는 함수로 인식하지 않고 변수로 인식합니다.</p><a href="https://joshua1988.github.io/web-development/javascript/function-expressions-vs-declarations/" target="_blank" rel="noopener">참고 : 함수 표현식 vs 함수 선언식</a><blockquote><p>let, var, const의 차이점에 관해서 설명해주세요.</p></blockquote><p>var 키워드를 사용하여 선언된 변수는 해당 변수의 함수 스코프 또는 전역 스코프를 가집니다.<br>반면에 let과 const 블록 범위입니다. 즉, 가장 가까운 중괄호(function, if-else 블록 또는 for-loop) 내에서만 접근할 수 있습니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">// 함수 내에서 모든 변수에 접근할 수 있습니다.</span></span><br><span class="line">  <span class="keyword">var</span> bar = <span class="string">'bar'</span>;</span><br><span class="line">  <span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line">  <span class="keyword">const</span> qux = <span class="string">'qux'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">// "bar"</span></span><br><span class="line">  <span class="built_in">console</span>.log(baz); <span class="comment">// "baz"</span></span><br><span class="line">  <span class="built_in">console</span>.log(qux); <span class="comment">// "qux"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// ReferenceError: bar가 정의되지 않았습니다</span></span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// ReferenceError: baz가 정의되지 않았습니다</span></span><br><span class="line"><span class="built_in">console</span>.log(qux); <span class="comment">// ReferenceError: qux가 정의되지 않았습니다</span></span><br></pre></td></tr></tbody></table></figure></div></figure><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) {</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="string">'bar'</span>;</span><br><span class="line">  <span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line">  <span class="keyword">const</span> qux = <span class="string">'qux'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// var로 선언된 변수는 함수 스코프의 어디에서나 접근할 수 있습니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// "bar"</span></span><br><span class="line"><span class="comment">// let과 const로 정의된 변수는 정의된 블록 외부에서 접근할 수 없습니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// ReferenceError: baz가 정의되지 않았습니다</span></span><br><span class="line"><span class="built_in">console</span>.log(qux); <span class="comment">// ReferenceError: qux가 정의되지 않았습니다</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>var는 변수가 올라가도록 허용합니다. 즉, 변수가 선언되기 전에 코드에서 참조 될 수 있습니다. let과 const는 이것을 허락하지 않고 대신 에러를 던집니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// ReferenceError: 초기화 전에 렉시컬 선언 `baz`에 접근할 수 없습니다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// ReferenceError: 초기화 전에 렉시컬 선언 `bar`에 접근할 수 없습니다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">'bar'</span>;</span><br></pre></td></tr></tbody></table></figure></div></figure><p>var을 사용하여 변수를 다시 선언해도 오류는 발생하지 않지만 ‘let’과 ‘const’는 오류를 발생시킵니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// "bar"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">'qux'</span>; <span class="comment">// SyntaxError: let baz의 재선언</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>let은 변수의 값을 재할당 할 수 있지만 const는 재할당 할 수 없다는 점이 다릅니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 괜찮습니다</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">'foo'</span>;</span><br><span class="line">foo = <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 예외가 발생합니다</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="string">'baz'</span>;</span><br><span class="line">baz = <span class="string">'qux'</span>;</span><br></pre></td></tr></tbody></table></figure></div></figure><a href="https://github.com/yangshun/front-end-interview-handbook/tree/master/Translations/Korean" target="_blank" rel="noopener">참고 : 프론트엔드 인터뷰 핸드북</a>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;프론트엔드 면접은행 - Javascript관련 질문 정리&lt;br&gt;
    
    </summary>
    
      <category term="인터뷰 문제은행" scheme="http://ksw1652.github.io/categories/%EC%9D%B8%ED%84%B0%EB%B7%B0-%EB%AC%B8%EC%A0%9C%EC%9D%80%ED%96%89/"/>
    
    
      <category term="FrontEnd" scheme="http://ksw1652.github.io/tags/FrontEnd/"/>
    
      <category term="Interview" scheme="http://ksw1652.github.io/tags/Interview/"/>
    
      <category term="Question" scheme="http://ksw1652.github.io/tags/Question/"/>
    
      <category term="Javascript" scheme="http://ksw1652.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Front-End Interview Question - CSS Question</title>
    <link href="http://ksw1652.github.io/2018/08/14/front-end-interview-css-question/"/>
    <id>http://ksw1652.github.io/2018/08/14/front-end-interview-css-question/</id>
    <published>2018-08-14T04:02:00.000Z</published>
    <updated>2018-08-27T06:45:09.152Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><blockquote><p><strong>class와 id의 차이점에 관해서 설명해주세요.</strong></p></blockquote><p>id 선택자와 class 선택자의 차이는 문서 안의 ‘복수’의 요소에 스타일을 적용하는 것인가 아니면 ‘유일’한 요소에 스타일을 적용하는 것인가 입니다.</p><blockquote><p>“reset” CSS가 무엇인지, 어떻게 유용한지 설명해주세요.</p></blockquote><p>각 브라우저는 본인만의 기본 스타일이 지정되어있습니다.<br>이 때문에 개발자가 명세한 스타일이 깨지는 경우가 있는데, 이를 방지하고 브라우저마다 공통된 스타일을 적용하기 위하여 사용합니다.</p><blockquote><p>float가 어떻게 동작하는지 설명해주세요.</p></blockquote><p>float은 ‘뜨다’라는 의미로 보통 CSS 상에서 정렬하기 위해 사용되는 속성입니다.<br>일반적인 블락(Block)요소는 기본값으로 width:100%; 의 값을 가지는데 플롯 속성이 선언되면,<br>좌측 혹은 우측에 다른 요소를 배치하기 위해 자신의 너비를 최소화 하게 됩니다.<br>예를 들어 리스트 레이아웃과 같이 좌측 혹은 우측에 이미지를 배치하고 나머지 영역에 텍스트를 보여줄 때,<br>이미지태그에 float:left;, float:right;를 사용하게 되면 이미지는 지정한 방향으로 정렬되고,<br>텍스트 영역이 나머지 부분을 차지하게 됩니다.<br>이때 텍스트에 margin이나 높이갚을 지정 할 수 없는데 텍스트 영역에 float을 지정하지 않았기 때문입니다.<br>이를 위해 overflow:hidden; 을 지정하여 주면 원하는 높이와 margin or padding을 지정 할 수 있습니다.</p><blockquote><p>z-index에 관해 설명해주세요.</p></blockquote><p>z-index는 겹치는 요소들간에 어떤 것을 상위에 표시할 것인지에 대한 명시값입니다.<br>z-index 를 사용하기 위해서는 기억해야할 3가지 사항이 있습니다.<br>우선 z-index 값을 지정하기 위해서는 해당 요소의 position 속성이 relative, absolute, fixed 중 하나여야만 합니다.<br>포지션 값이 지정되지 않으면 해당 요소들은 z-index:0; 처럼 동작합니다.<br>두 번째로 z-index의 값은 같은 depth의 요소끼리 비교하는 것이 원칙입니다.<br>같은 depth에서 하위로 자식 엘리먼트가 있는경우, 이는 z-index의 고려대상이 되지 않습니다.<br>마지막으로 z-index의 기본값은 auto이며, 이 경우 브라우저는 그 요소를 제쳐두고 자식 요소의 z-index 값을 비교대상으로 삼습니다.<br><a href="http://dev.epiloum.net/904" target="_blank" rel="noopener">참조 링크:퀴즈로 풀어보는 CSS z-index 속성의 3가지 포인트</a></p><blockquote><p>BFC(Block Formatting Context)에 관해 설명해주세요</p></blockquote><p>Bock Formatting context는 다음 조건중 하나 이상을 만족하는 HTML BOX입니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. float 값은 none이 아닙니다.</span><br><span class="line">2. position의 값은 static도 relative도 아닙니다.</span><br><span class="line">3. display 값은 table-cell, table-caption, inline-block, flex 또는 inline-flex입니다.</span><br><span class="line">4. 오버플로 값은 표시되지 않습니다.</span><br></pre></td></tr></table></figure></p><blockquote><p>클리어링(Clearing) 기술에는 어떤 것들이 있으며, 어떨 때 어떻게 사용하는 것이 적절한지 설명하세요.</p></blockquote><p>클리어링은 float 속성을 사용할 때 태그를 부유시킨 이후 문서의 흐름을 제거하기 위해 쓰입니다.<br>방향에 따라 3가지 속성을 사용할 수 있습니다.</p><ol><li>left: 좌측 부유 제거</li><li>right: 우측 부유 제거</li><li>both: 양쪽 모두 제거</li></ol><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/5zm7q1cb/embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe><blockquote><p>CSS 스프라이트(CSS Sprites)를 설명하고, 페이지나 사이트를 어떻게 향상하는지 설명하세요.</p></blockquote><p>CSS 스프라이트는 사이트의 성능향상을 위하여 여러개의 이미지를 합쳐서 하나의 이미지로 만들고 이를 잘라 사용하는 방식입니다.<br>예를 들어 한 페이지에서 10개의 이미지 리소스가 필요한 경우,<br>원격지로 부터 10번의 요청을 해야하지만 CSS 스프라이트 기법을 사용하면 한 번의 요청으로 이미지를 받아온 후 화면에 렌더링 할 수 있습니다.</p><blockquote><p>Image Replacement를 사용해야 할 때와, 선호하는 기술을 설명해주세요.</p></blockquote><p>Image Replacement는 웹 접근성을 준수하여 시각장애인에게(이미지를 볼 수 없는 상황) 대체텍스트를 제공하는 방법입니다.<br>첫 번째 방법은 Text-indent를 활용한 방법입니다.<br>text-indent 속성 값에 현재 사용되고 있는 디스플레이의 해상도보다 작은 음의 정수 값을 주는 방법입니다.<br>두 번재 방법은 높이와 넓이를 0으로 설정하는 방법입니다.<br>이 방법은 대체 텍스트 글자가 들어가는 등의 요소의 높이와 너비를 0으로 지정하는 방법입니다.<br>먼저, 대체할 텍스트 요소에 BackGround 이미지를 설정한 다음 대체 텍스트가 포함되는 요소의 높이와 너비를 0으로 지정합니다.</p><blockquote><p>브라우저 스펙 차이에 따른 스타일링 이슈를 수정하기 위해서 어떻게 접근하나요?</p></blockquote><p>reset css와 nomalize css를 사용하여 초기화 한 후 스타일링 합니다.</p><blockquote><p>기능이 제약된 브라우저를 위해서 어떤 방식으로 페이지를 만드나요?</p><ul><li>어떠한 기술과 절차를 거치는지 설명하세요.</li></ul></blockquote><p>(어떤 기능인지 정확히 명시해줬으면….)<br>IE 10이하 버전의 경우 스크립트가 동작하지 않는 경우가 있기 때문에<br>user-agent 사용자의 브라우저를 판별하고 이에 대한 alert나 상단에 문구를 표시하는 편입니다.</p><blockquote><p>시각적으로 보이지 않고 스크린 리더에서만 가능하게 하는 방법에 관해 설명해주세요.</p></blockquote><ol><li>display:none; (영역 자체가 없어지면서 컨텐츠가 안보임)</li><li>visibility:hidden; (영역은 존재하고 컨텐츠만 안보임)</li><li>box 요소 크기를 작게하고(width:0; height:0;) overflow:hidden; 사용</li><li>text-indent, position 등에 음수를 사용<br>출처: <a href="http://zinee-world.tistory.com/121" target="_blank" rel="noopener">http://zinee-world.tistory.com/121</a> [zineeworld]</li></ol><blockquote><p>그리드 시스템(Grid system)을 사용한 적이 있나요? 있다면 어떠한 것을 선호하나요?</p></blockquote><p>디자인 프레임워크인 부트스트랩과 Angular Matiral을 사용해보았습니다.<br>또한 Ionic은 기본 스펙으로 그리드를 제공하기 때문에 주로 사용하였습니다.<br>주로 12 Column Grid System을 사용합니다.</p><blockquote><p>미디어 쿼리(media queries)를 사용한 적이 있나요? 혹은 모바일에 맞는 layout과 CSS를 사용한 적이 있나요?</p></blockquote><p>일전에 ‘(주)비피도 쇼핑몰’을 제작할 때 사용하였습니다.<br>미디어 쿼리를 통해 모바일, 웹사이트로 크기를 나누고, 이를 각각 스타일링 하였습니다.</p><blockquote><p>SVG를 스타일링하는데 익숙하신가요?</p></blockquote><p>아니요, 익숙해질 예정입니다.</p><blockquote><p>인쇄하기 위해 웹페이지를 어떻게 최적화 하나요?</p></blockquote><p>미디어쿼리를 사용해 print용 스타일을 따로 만듭니다.</p><blockquote><p>효율적인 CSS를 작성하기 위한 “비법(gotchas)”은 어떤 게 있나요?</p></blockquote><ol><li>id selector와 class selector을 구분하고 최대한 공통된 스타일링을 사용합니다.</li><li>CSS 엔진의 색인 속도를 높이도록 우선순위를 고려하여 스타일 합니다.</li><li>!important의 사용과 인라인 스타일의 사용을 최대한 지양합니다.</li></ol><blockquote><p>CSS 전처리(CSS preprocessors)를 사용해보셨나요?</p><ul><li>그렇다면, 사용 경험에 기반을 둬 좋았던 점과 나빴던 점을 설명해주세요.</li></ul></blockquote><p>주로 sass를 사용합니다.<br>sass를 사용했을 때의 좋은 점은 우선 다양한 기능(mixin, import등)을 사용할 수 있어스타일링의 추상화가 가능하단 점입니다.<br>나빴던 점은 직접적인 스타일링이 아니라 Html과 같이 계층형으로 코딩한 후 컴파일 되기 때문에 CSS로 작성했을 때보다 코드의 양이 늘어난다는 점입니다.</p><blockquote><p>페이지에서 표준 폰트가 아닌 폰트 디자인을 사용할 때 어떤 방식으로 처리하시나요? (웹폰트를 제외하고)</p></blockquote><p>eot, woff, woff2와 같은 파일을 import하여 사용합니다.</p><blockquote><p>CSS Selector가 어떠한 원리로 동작하는지 설명해주세요.</p></blockquote><p>CSS 엔진은 오른쪽에서 왼쪽으로 이동하면서 엘리먼트가 규칙에 적합한지 확인합니다.<br>만약 엘리먼트가 이 규칙에 적합하지 않으면 멈추게 됩니다.</p><blockquote><p>pseudo-elements에 관해서 설명하고 어디에서 사용되는지 이야기해보세요.</p></blockquote><p>CSS pseudo-elements는 element의 지정된 부분을 스타일화하는 데 사용됩니다.<br>예를 들어 다음과 같이 사용할 수 있습니다.</p><ul><li>요소의 첫 번째 문자 또는 선 스타일 지정</li><li>요소의 내용 앞이나 뒤에 내용 삽입</li></ul><blockquote><p>box model에 관해 설명하고 브라우저에서 어떻게 동작하는지 설명해주세요.</p></blockquote><p>HTML의 모든 엘리먼트는 width(너비)와 height(높이)를 가지는 사각형 박스이며 안쪽에서 부터 바깥쪽으로 content(컨텐츠) -&gt; padding(패딩) -&gt; border(보더) -&gt; margin(마진)으로 구성되어 있습니다.<br>엘리먼트에서 실제너비는 마진을 제외한 (content width) + (padding left) + (padding right) + (border left) + (border right)값입니다.<br>실제 높이 역시 (content height) + (padding top) + (padding bottom) + (border top) + (border bottom)값이 됩니다.</p><a href="https://nolboo.kim/blog/2013/07/22/beginners-guide-to-html-and-css-3-slash-10/" target="_blank" rel="noopener">HTML & CSS 초보자 가이드 - 3강 : Box Model & Positioning</a><blockquote><p><code>* { box-sizing: border-box; }</code> 은 무엇이고 사용했을때 이점은 무엇인가요?</p></blockquote><p>일반적으로 box model은 컨텐츠의 너비 혹은 높이 + 패딩 + 보더를 포함합니다.<br>이 때문에 패딩 값이 늘어나면 box model의 값이 커지는 문제가 발생할 수 있습니다.<br>그러나 box-sizing: border-box;를 설정하게 되면 패딩이나 border값이 늘어나도 box model의 크기는 변하지 않으며 컨텐츠의 표시영역이 줄어들어 일관된 사이즈를 유지할 수 있습니다.</p><blockquote><p>기억나는 display 속성에 대한 값들을 나열해보세요.</p></blockquote><p>display: inline;<br>display: inline-block;<br>dispaly: block;<br>display: none;<br>display: flex;</p><blockquote><p>inline과 inline-block의 차이점은 무엇인가요?</p></blockquote><p>inline 속성을 가진 태그는 가로폭을 전부 차지 하지 않고 상위 태그 옆으로 붙는 특징이 있습니다.<br>또한 width와 height값을 지정해도 크기는 변하지 않습니다.<br>반면 block 속성을 가진 태그는 가로폭을 전부 차지하며 width, height값을 가질 수 있습니다.<br>inline-block는 이러한 inline 속성과 block속성의 특징을 모두 가지고 있는 속성으로서<br>가로폭을 전부 차지하지 않고, width와 height 값을 가질 수 있습니다.</p><blockquote><p>요소를 배치하는 방법(relative, fixed, absolute, static) 간의 차이는 무엇인가요?</p></blockquote><p><strong>static:</strong> HTML Element는 position의 기본값으로 static 값을 가지며 static으로 배치된 Element는 위, 아래, 오른쪽, 왼쪽 속성의 영향을 받지 않습니다.<br><strong>relative:</strong> relative 속성은 static과는 달리 top, bottom, left, right 값을 통해 Element의 위치를 변경할 수 있습니다.<br><strong>fixed:</strong> 뷰포트를 기준으로 배치되므로 페이지가 스크롤 되어도 항상 같은 위치에 유지됩니다.<br><strong>absolute:</strong> 가장 가까운 위치에있는 부모 엘리먼트를 기준으로 배치됩니다. 만약 absolute 속성의 부모가 없다면 페이지 스크롤과 함께 움직입니다.</p><blockquote><p>CSS에서 ‘C’는 Cascading을 의미합니다. Cascading에 관해서 설명해주세요. 또 cascading system의 장점은 무엇인가요?</p></blockquote><p>Cascading은 계단모양의 폭포를 의미하며 CSS에서 스타일 시트의 <strong>우선순위</strong>를 지정하는 방식이 폭포수와 닮아 붙여진 의미 입니다.<br>cascading system을 사용하였을 때의 장점은 HTML Element마다 일일이 스타일을 지정하지 않아도 되므로 렌더링 속도와 코드의 양을 줄여 성능 향상에 기여할 수 있습니다.</p><blockquote><p>CSS framework를 사용해본 적이 있으신가요? 실무에서 사용해보았다면 어떤 이점이 있었나요?</p></blockquote><p>부트스트랩, Angular Material을 사용해보았습니다.<br>실무에서 사용했을때 우선 직접적으로 모든 스타일링을 하지 않고,<br>프레임워크에서 제공하는 컴포넌트들을 사용하기 때문에 시간을 절약할 수 있습니다.<br>또한 사용자에게 일관된 디자인을 제공할 수 있습니다.</p><blockquote><p>새로운 CSS Flexbox 혹은 Grid 스펙을 사용해 보신 적 있나요?</p></blockquote><p>주로 스타일링을 할 때 flexbox를 사용합니다.</p><blockquote><p>반응형(Responsive) 디자인은 적응형(Adaptive) 디자인과 어떤 차이점이 있나요?</p></blockquote><p>반응형 디자인은 기기별 사이즈에 따라 알맞은 크기로 콘텐츠를 제공하고, 사이즈별 제공하는 콘텐츠의 차이가 없는 디자인 입니다.<br>반면에 적응형 디자인은 미리 정해진 몇 가지 화면 크기를 기준으로 두고 비율에 맞춰 페이지를 구성하는 방식입니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;휴가를 다녀온 뒤 오랜만에 포스트를 올린다.&lt;br&gt;이전의 HTML 질문편에 이어서 CSS관련 인터뷰 질문을 올려본다.&lt;br&gt;
    
    </summary>
    
      <category term="인터뷰 문제은행" scheme="http://ksw1652.github.io/categories/%EC%9D%B8%ED%84%B0%EB%B7%B0-%EB%AC%B8%EC%A0%9C%EC%9D%80%ED%96%89/"/>
    
    
      <category term="FrontEnd" scheme="http://ksw1652.github.io/tags/FrontEnd/"/>
    
      <category term="Interview" scheme="http://ksw1652.github.io/tags/Interview/"/>
    
      <category term="CSS" scheme="http://ksw1652.github.io/tags/CSS/"/>
    
      <category term="Question" scheme="http://ksw1652.github.io/tags/Question/"/>
    
  </entry>
  
  <entry>
    <title>Front-End Interview Question - HTML Question</title>
    <link href="http://ksw1652.github.io/2018/08/02/front-end-interview-html-question/"/>
    <id>http://ksw1652.github.io/2018/08/02/front-end-interview-html-question/</id>
    <published>2018-08-02T08:13:00.000Z</published>
    <updated>2018-08-11T19:15:47.370Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><blockquote><p><strong>doctype이 무엇을 하는 것인가요?</strong></p></blockquote><p>HTML의 버전을 명시하는 태그 입니다.</p><blockquote><p><strong>표준모드(standards mode)와 쿽스모드(quirks mode)의 다른 점은 무엇인가요?</strong></p></blockquote><p>브라우저가 출력하고자 하는 문서가 최신이라고 판단하면 표준모드(standard mode)로 렌더링 합니다.<br>반면 브라우저가 예전문서라고 판단을 하면 쿼크 모드(quirks mode)로 렌더링을 하게 되며 이 모드에서는 이전 세대의 브라우저에 맞는 비표준적 방법의 CSS를 적용합니다.<br>즉 쿼크모드의 목적은 오래된 웹페이지들이 최신 버전의 브라우저에서 깨져 보이지 않으려는 것에 있습니다.</p><blockquote><p><strong>XML과 XHTML의 다른 점은 무엇인가요</strong></p></blockquote><p>XML은 드라이버 하드웨어, 운영 체제 및 다양한 응용 프로그램 간에 데이터를 전송하도록 설계 된 마크업언어지만 XHTML은 XML의 강점을 HTML과 결함한 언어입니다.</p><blockquote><p><strong>application/xhtml+xml으로 지정한 페이지에 어떠한 문제가 있나요?</strong></p></blockquote><p>ie11 하위 버전에서는 XHTML을 제대로 지원하지 않습니다.<br>XHTML의 XML 기능을 사용하기 위한 필수 요구 조건인 application/xhtml+xml MIME 타입을 인식하지 못합니다.</p><blockquote><p><strong>다국어 페이지를 제공하는 여러 방법에 관해 설명해주세요.</strong></p></blockquote><p>지원하는 방법은 크게 3가지 입니다.<br>첫 번째는 템플릿 페이지를 언어별로 작성하여 보여주는 방법, 두 번째는 data-* 속성을 이용하여 언어별 텍스트를 배열로 만들고 처리하는 방법,<br>마지막으로 i18n 라이브러리를 사용 하는 방법입니다.</p><blockquote><p><strong>data-속성은 무엇을 하는 것인가요? 사용했을 때 이점은 무엇인가요?</strong></p></blockquote><p>HTML5에서 새로 추가된 data- 속성은 커스텀 데이터 속성으로, 개발자가 임의로 이름을 붙일 수 있는 속성입니다. data- 속성은 html 태그 상에서 별다른 작용을 하지 않습니다. 자바스크립트가 DOM의 데이터에 접근하거나 서버에서 받아온 데이터를 활용해야 할 때 사용됩니다.</p><blockquote><p><strong>HTML5를 오픈 웹 플랫폼(open web platform)으로 생각해본다면, 어떤 것들로 구성돼 있을까요?</strong></p></blockquote><p>시멘틱 마크업, 미디어 핸들링을 위한 내장 플렛폼, application API, 오프라인 핸들러</p><blockquote><p><strong>쿠키(Cookies)와 세션저장소(sessionStorage)와 로컬저장소(localStorage)의 차이점을 설명해주세요.</strong></p></blockquote><p>쿠키(Cookie), 세션 저장소(sessionStorage), 로컬 저장소(localStorage)는 브라우저에 데이터를 저장하기 위한 공간들입니다.<br>HTML5 이전에는 쿠키를 주로 사용했습니다. 하지만 쿠키는 많은 양의 데이터를 저장할 수 없고, 동일한 도메인에 페이지를 요청할 때마다 서버로 함께 전송되며, 변조가 쉬워 보안이 취약합니다.<br>그래서 HTML5부터는 저장소 객체(Storage object)를 정의하고 있습니다.<br>저장소 객체는 세션 저장소(sesssionStorage)와 로컬 저장소(localStorage) 두 가지가 있습니다.<br>두 가지 모두 키-값의 형태로 보존되며 string 값으로 저장되기 때문에 실제 Javascript에서 사용하려면 파싱 과정을 거쳐야 합니다.<br>localStroage에 데이터를 자장하면 창이나 탭을 닫아서 세션이 종료돼도 데이터가 보존됩니다.<br>반면에 sessionStorage는 페이지 세션이 만료되면 데이터도 파기됩니다.</p><blockquote><p><strong><code>&lt;script&gt;</code>, <code>&lt;script async&gt;</code>와 <code>&lt;script defer&gt;</code>의 차이점에 관해 설명해주세요.</strong></p></blockquote><p>일반적으로 브라우저는 <code>&lt;script&gt;</code> 태그를 만나면 웹 페이지 렌더링을 잠시 중단하고 script를 해석한 후 실행합니다.<br>따라서 사이즈가 크거나 복잡한 script을 가져올 경우 브라우저가 느려지는 단점이 있습니다.<br>하지만 async와 defer 키워드를 사용하게 되면 브라우저 렌더링과 동시에 스크립트를 내려받습니다.<br>여기서 async와 defer의 차이점은 async의 경우 script를 내려받는 즉시 실행하며 defer는 렌더링이 완료된 후 실행합니다.</p><blockquote><p><strong>CSS<link>를 <code>&lt;head&gt;&lt;/head&gt;</code> 사이에 쓰는 것과 JS<code>&lt;script&gt;</code> 를 <code>&lt;body&gt;&lt;/body&gt;</code> 뒤에 사용하는 것은 좋은 사용법일까요? 어디에 배치하는 게 좋을까요?</strong></p></blockquote><p>이전 포스트에서 설명했듯이 css 는 head태그 안에, JS는 body 하단에 표시해야합니다. 그 이유는 브라우저가 DOM해석하고 렌더링 하면서 CSS명세를 적용하여 렌더링합니다.<br>이때 JS를 만나게 되면 렌더링을 잠시 멈추고 JS를 다운 받아실행하게 됩니다. 이러한 성능저하 현상을 줄이기 위해 body 최 하단에 JS를 배치하면 렌더링이 대부분 완료되고<br>JS를 다운받아 실행하기 때문에 사용자 입장에서 성능 저하를 느낄 수 없게 됩니다.</p><blockquote><p><strong>Progressive rendering이란 무엇인가요?</strong></p></blockquote><p>Progressive rendering은 이름 그대로 가능한 빨리 웹의 컨텐츠를 그리기 위한 기술입니다.<br>대표적으로 이미지 Lazy-loading과 같은 기술이 있습니다.</p><blockquote><p><strong>이미지 태그에 srcset 속성을 사용하는 이유는 무엇인가요? 브라우저가 이 속성을 가진 콘텐츠를 평가할 때 사용하는 과정을 설명해보세요.</strong></p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">html</li></ul></figcaption><div class="tabs-content"><figure class="highlight html" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"small.jpg"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">srcset</span>=<span class="string">"large.jpg 1024w, medium.jpg 640w, small.jpg 320w"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">sizes</span>=<span class="string">"(min-width: 36em) 33.3vw, 100vw"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">alt</span>=<span class="string">"A rad wolf"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>화면 해상도에 따라서 이미지를 제공하기 위한 속성입니다.<br>위 코드에서와 같이 1024w는 이미지의 실제사이즈를 의미하며 화면의 width에 따라 브라우저가 각기 다른 이미지를 보여주게 됩니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;프론트엔드 면접은행 - HTML관련 질문 정리&lt;br&gt;
    
    </summary>
    
      <category term="인터뷰 문제은행" scheme="http://ksw1652.github.io/categories/%EC%9D%B8%ED%84%B0%EB%B7%B0-%EB%AC%B8%EC%A0%9C%EC%9D%80%ED%96%89/"/>
    
    
      <category term="FrontEnd" scheme="http://ksw1652.github.io/tags/FrontEnd/"/>
    
      <category term="Interview" scheme="http://ksw1652.github.io/tags/Interview/"/>
    
      <category term="Question" scheme="http://ksw1652.github.io/tags/Question/"/>
    
      <category term="HTML" scheme="http://ksw1652.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Front-End Interview Question - Normal Question</title>
    <link href="http://ksw1652.github.io/2018/07/31/front-end-interview-nomal-question/"/>
    <id>http://ksw1652.github.io/2018/07/31/front-end-interview-nomal-question/</id>
    <published>2018-07-31T01:14:00.000Z</published>
    <updated>2018-08-11T19:15:47.366Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h1 id="프론트-엔드-면접은행"><a href="#프론트-엔드-면접은행" class="headerlink" title="[프론트 엔드 면접은행]"></a>[프론트 엔드 면접은행]</h1><p>곧 있을 면접과 앞으로의 프론트엔드 면접을 위하여 <strong>프론트엔드 면접 문제 은행</strong>의 질문들을 개인적으로 정리하려 한다.<br>참조한 곳은 <a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions" target="_blank" rel="noopener">https://github.com/h5bp/Front-end-Developer-Interview-Questions</a> 이곳이며, 한국어 버전이 번역되어 git에 올라가 있다.<br>(<a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/tree/master/Translations/Korean#js-%EA%B4%80%EB%A0%A8-%EC%A7%88%EB%AC%B8" target="_blank" rel="noopener">https://github.com/h5bp/Front-end-Developer-Interview-Questions/tree/master/Translations/Korean#js-%EA%B4%80%EB%A0%A8-%EC%A7%88%EB%AC%B8</a>)</p><p>일반적인 질문부터 HTML, CSS, Javascript에 대한 Front-End 전반적인 질문들에 대한 답을 적어보려 한다. 질문에 대한 답변은 계속해서 업데이트 할 예정이다.</p><hr><blockquote><p><strong>어제/이번 주에 무엇을 공부하셨나요?</strong></p></blockquote><p>이번주에는 Javascript Prototype에 대하여 공부하고 정리하였습니다.<br>Prototype에 대해 간단하게 설명하면 우리가 일반적으로 이야기 하는 Javascirpt Prototype은 Prototype Link와 Prototype Object로 구성되어 있으며,<br>Prototype Link는 하위 객체가 참조하는 상위객체를 일컫고, Prototype Object는 자신을 복제할 하위 객체가 참조할 Object, 즉 분신입니다.</p><blockquote><p><strong>코딩을 할 때 당신을 들뜨게 하거나 흥미를 끄는 것들은 무엇은 가요?</strong></p></blockquote><p>새로운 기술과 이를 적용하여 프로젝트를 구현하고 눈으로 확인했을 때 가장 흥미를 느낍니다.</p><blockquote><p><strong>최근에 당신이 경험한 기술적인 문제는 무엇이고 그것을 어떻게 해결했나요?</strong></p></blockquote><p>가장 최근에 진행한 Vue.js로 구현한 빙고 페이지에서 페이지 렌더링을 하는 도중 에러가 발생하였습니다.<br>에러가 발생한 이유는 데이터를 받아오는 시점에서 일반적인 RESTFul API가 아닌 Android Interface를 통해 데이터를 받아오기 때문에 시점에 대한 이슈가 발생하였습니다.<br>이를 해결하기 위해 Javascript Event Dispatcher를 사용하여 데이터를 주고받았고, async / await를 사용하여 동기화처리를 함으로서 렌더링 이슈를 해결하였습니다.</p><blockquote><p><strong>웹 애플리케이션이나 사이트를 만들 때 고려해야 할 UI, Security, Performance, SEO, Maintainability에 대해서 설명해주세요.</strong></p></blockquote><p>UI : PC용 웹사이트와 모바일 사이트를 하나의 도메인에서 서비스하려면 반응형 디자인으로 페이지를 구현합니다. 또는 두개의 도메인을 구분하려면 PC용, Mobile용을 따로 디자인하여 퍼블리싱하면 됩니다.</p><p>Security : 제가 진행했던 보안적인 처리는 SPA내에서 DOM에 직접적으로 접근하지 않고, 각 FE프레임워크 또는 라이브러리(Angular, React, Vue.js)에서 권장하는 방식으로 접근하는 것입니다.<br>두번 째 방법은 입력 폼 양식에 대하여 유효성 체크를 FrontEnd와 BackEnd 둘다 처리합니다. 이렇게 했을 때 invalild Data나 잘못된 파일이 업로드 되었을 때의 피해를 최소화 할 수 있습니다.<br>마지막으로 페이지에 대한 router를 auth처리하여 인증된 사용자만 접근할 수 있도록 구분하는 것입니다. 이렇게 하였을때 무분별하게 페이지접근이나 요청을 막을 수 있습니다.<br>추가로 LocalStorage대신 sessionStorage를 사용하는 것도 좋은 방법입니다.</p><p>Performance : FrontEnd에서 성능향상을 위하여 기본적으로는 우선 style태그는 <head>태그 내에, script태그는 </head><body> 최하단에 배치시키는 것입니다. 이렇게 하는 이유는 브라우저에의해 DOM이 생성되고 렌더링 되면서 우선적으로는 style이 적용되어야 하고, script는 마지막에 불려와 로직이 적용되어야 하기 때문입니다.<br>두번째 방법은 FE프레임워크마다 다르겠지만 우선 Virtual DOM을 사용하는 것입니다. Angular의 경우 Virtual DOM을 기본스펙으로 제공하지 않기 때문에 페이지를 리플로우 / 리드로우 할때 체감상 상당히 느리게 느껴집니다. 그러나 Vue.js의 경우 Virtual Dom을 사용하기 때문에 리플로우 / 리드로우 시간을 최소화 할 수 있습니다.<br>마지막으로 프로젝트를 완료 후 빌드할 때에는 공통적으로 Uglify, Minify, Gzip 프로세스를 추가하여 브라우저에서 JS나 CSS를 로드할 때의 시간을 최소화하면 성능향상을 기대 할 수 있습니다.</body></p><p>SEO : 검색엔진 최적화를 위하여 <code>&lt;title&gt;</code> 태그와 <code>&lt;meta&gt;</code> 태그들에 대한 정보를 모두 입력합니다.<br>또한 Robot.txt를 사용합니다.<br><code>&lt;a&gt;</code> 태그를 사용합니다.</p><p>Maintainability : 코드 컨벤션을 정의합니다. 이는 팀원들간의 유지보수을 쉽고 빠르게 유지할 수 있습니다. 간단하게는 네이밍 부터 HTML, CSS, Javascript까지 정의합니다. linter를 사용합니다. 여러 종류의 linter가 있지만 린터를 사용하였을 때 유지보수가 용이해지고 코트의 품질이 올라갑니다.</p><blockquote><p><strong>선호하는 개발 환경에 대해 자유롭게 이야기해 주세요.</strong></p></blockquote><p>기존 경력동안 사용한  OS는 MAC 이며 IDE는 WebStorm입니다.</p><blockquote><p><strong>버전 관리 시스템은 어떤 것들을 사용해보셨습니까?</strong></p></blockquote><p>git과 BitBucket를 주로 사용하였습니다.</p><blockquote><p><strong>당신이 웹 페이지를 만들 때의 과정을 설명해주실 수 있을까요?</strong></p></blockquote><p>기획과 디자인이 모두 완료된 상태에서 첫 작업은 퍼블리싱입니다. 퍼블리싱을 작업하여 반응형일 경우 모바일과 PC버전의 화면을 체크하고 MockData를 삽입하여 실제 데이터가 표시 된 것처럼 작업합니다. 이후 로직단을 작업하여 RESTFul API를 통해 데이터를 가져오거나 추가 로직을 입힙니다. 이후 UI와 로직 모두 테스팅을 진행하며 시나리오 대로 페이지가 동작하는지 확인합니다.</p><blockquote><p><strong>당신에게 5가지 다른 stylesheet가 있습니다. 어떤 방법으로 사이트에 제공하는 게 가장 효과적일까요?</strong></p></blockquote><p>(질문자의 의도를 모르겠음)<br>사용자 분석을기반으로 각각 다른 스타일을 제공하면 좋을 것 같습니다.</p><blockquote><p><strong>점진적 향상법(progressive enhancement)과 우아한 성능저하법(graceful degradation)의 차이를 설명하실 수 있습니까?</strong></p></blockquote><p>점진적 향상법은 많은 테스팅을 통해 기능을 점진적으로 향상시키는 것을 의미하며 우아한 성능저하법은 최신기기에서 동작하는 기능을 만들고 난 다음에 오래된 기기에서 동작할 수 있도록 다른 버전을 두어 관리 또는 만드는 것을 의미합니다.</p><blockquote><p><strong>브라우저가 한 번에 1개의 도메인에서 내려받는 자원은 몇 개인가요?</strong></p></blockquote><p>이번 질문을 보고 공부하게된 내용입니다.<br>브라우저마다 다르겠지만 평균 6~8개의 리소스를 동시에 받을 수 있습니다.</p><blockquote><p><strong>페이지 로드 시간을 줄이는 세 가지 방법에 관해서 이야기 해 보세요.</strong></p></blockquote><p>css Image Spirte를 사용합니다. 또한 js 파일을 minify, uglify하여 하나의 파일로 로드합니다. gzip을 사용합니다. 캐싱을 적용합니다.</p><blockquote><p><strong>당신이 프로젝트에 합류했습니다. 근데 그들은 Tab을 이용하고, 당신은 Space를 사용했습니다. 어떻게 하실 건가요?</strong></p></blockquote><p>팀의 코드 컨벤션을 유지합니다. 제가 우선시하는 것은 개인적인 성향보다는 팀원들간의 커뮤니케이션이고 다른 사람의 코드를 볼때 빠른 이해가 중요합니다. 이를 위해 Tab이 서로간에 코드를 이해하는 것이 빠르다면 Tab을 사용할 것입니다. 어차피 빌드되면 다 똑같이 때문에 퍼포먼스와 같은 결과는 크게 차이나지 않을 것입니다.</p><blockquote><p><strong>간단한 Slideshow 페이지를 만드는 방법에 관해서 이야기해 보세요.</strong></p></blockquote><p>position: absolute; left: width; 를 기반으로 모든 페이지를 좌측으로 정렬 시키고, 자바스크립트로 left 값을 변경하는 식.<br>직접 스타일을 조작하는데 리플로우, 리드로우와 같이 퍼포먼스 문제가 있다면 CSS3 transform을 사용합니다.</p><blockquote><p><strong>만약 당신이 올해 기술적 책임자가 되었다면 무엇을 먼저 하시겠습니까?</strong></p></blockquote><p>팀내의 코드컨벤션을 정의 하겠습니다. 서로간의 코드를 이해하기 쉽고 유지보수가 용이해지도록 하기 위해서 입니다. 또한 페어 프로그래밍을 시도해 보고 싶습니다. 페어프로그래밍을 도입함으로서 코드를 작성한 개발자에게 모든 책임을 전가하는 것이 아닌 위급한 상황에서도 누구나 코드를 수정할 수 있도록 해야 합니다.</p><blockquote><p><strong>표준의 중요성에 관해 설명해주세요.</strong></p></blockquote><p>표준을 정의함으로서 팀원들 간에는 서로의 코드를 이해하고 수정하는 시간을 줄일 수 있다. 또한 코드를 작성한 개발자가 사정이 생기더라도 표준에의한 코딩을 함으로서 쉽게 다른 개발자가 코딩을 할 수 있게한다.</p><blockquote><p><strong>Flash of Unstyled Content에 관해 설명해주세요. 또 FOUC를 피하기 위해선 어떻게 해야 하나요?</strong></p></blockquote><p>기본적으로 CSS는 렌더링 차단 리소스로 취급된다. 즉 CSSOM이 생성될 때까지 브라우저는 처리되는 모든 콘텐츠를 로딩하지 않는다. 예를 들어 @import(참조된 CSS)를 사용하거나 자바스크립트로 인한 DOM 구조가 변결될때 FOUC가 발생한다.<br>이를 해결하기 위해 기본적으로는 <head>태그 안에 CSS를 링크하고 @import사용을 자제한다. 또한 자바스크립트의 순서를 바꿔주거나 특정 상황에서 FOUC가 발생하는 경우 미디어쿼리를 통해 처리 할 수 있다. (결론 : 클라이언트에서 최대한 빠르게 CSS를 다운로드하여 렌더링 해야함)</head></p><blockquote><p><strong>ARIA와 screenreader에 대해 설명해주세요</strong></p></blockquote><p>ARIA는 (Accessible Rich Internet Applications) 즉 웹 어플리케이션을 작성할 때 장애인을 위한 접근성 향상 방법을 정의한것.<br>screenreader는 시각장애인이 컴퓨터를 사용할 때 나타나는 정보들을 음성으로 출력해주는 프로그램이다.</p><blockquote><p><strong>CSS 애니메이션과 JavaScript 애니메이션의 차이점에 관해 설명해주세요</strong></p></blockquote><p>UI 요소 상태 전환과 같은 간단한 ‘원샷(one-shot)’ 전환에 CSS 애니메이션을 사용합니다.<br>바운스, 중지, 일시 중지, 되감기 또는 감속과 같은 고급 효과를 원할 경우에 자바스크립트 애니메이션을 사용합니다.<br>자바스크립트로 애니메이션을 만드는 경우, 자신에게 익숙한 Web Animations API 또는 최신 프레임워크를 사용합니다.</p><blockquote><p><strong>CORS는 무엇의 약자이고 어떤 문제에 대해서 언급하는 것인가요?</strong></p></blockquote><p>CORS는 Cross Origin Resource Sharing으로 다른 도메인에서 리소스를 공유할 수 있음을 의미한다. 기본적으로 스크립트는 Same Origin Policy에 의해 HTTP Request가 불가능하나 CORS를 허용하게 된다면 다른 도메인으로 HTTP Request가 가능해진다는 뜻이다. 이를 해결하기 위해선 여러가지 방법이 있는데, JSONP방식을 사용하거나 서버측에서 Access control을 허용하도록 설정해주면 된다.</p>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;곧 있을 면접과 앞으로의 프론트엔드 면접을 위하여 프론트엔드 면접 문제 은행의 질문들을 개인적으로 정리하려 한다.&lt;br&gt;
    
    </summary>
    
      <category term="인터뷰 문제은행" scheme="http://ksw1652.github.io/categories/%EC%9D%B8%ED%84%B0%EB%B7%B0-%EB%AC%B8%EC%A0%9C%EC%9D%80%ED%96%89/"/>
    
    
      <category term="FrontEnd" scheme="http://ksw1652.github.io/tags/FrontEnd/"/>
    
      <category term="Interview" scheme="http://ksw1652.github.io/tags/Interview/"/>
    
      <category term="Question" scheme="http://ksw1652.github.io/tags/Question/"/>
    
  </entry>
  
  <entry>
    <title>Javascript Prototype</title>
    <link href="http://ksw1652.github.io/2018/07/30/javascript-prototype/"/>
    <id>http://ksw1652.github.io/2018/07/30/javascript-prototype/</id>
    <published>2018-07-29T15:00:00.000Z</published>
    <updated>2018-08-12T02:27:52.503Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h1 id="자바스크립트-프로토타입"><a href="#자바스크립트-프로토타입" class="headerlink" title="[자바스크립트] 프로토타입"></a>[자바스크립트] 프로토타입</h1><p>자바스크립트는 프로토타입 기반 언어이다. 또한 객체지향 언어이기도 하다. 그러나 자바스크립트는 클래스 기념이 없다. 대신에 프로토타입(Prototype)이 존재한다.</p><p>클래스 개념이 없으니 기본적으로 상속기능도 없으며 보통 프로토타입을 기반으로 상속을 흉내내어 사용한다.<br>javascript는 <span class="highlight-text primary">프로토타입을 이용한 클로닝(Cloning)과 객체특성을 확장해 나가는 방식을 통해 새로운 객체를 생성하게 된다.</span><br>(참고로 ESMA6 표준에서는 Class 문법이 추가되었다. 하지만 문법이 추가 된 것이지 클래스 기반으로 바뀐 것이 아니다. 여전히 Prototype기반이다)</p><h2 id="자바스크립트의-프로토타입-Prototype-이란"><a href="#자바스크립트의-프로토타입-Prototype-이란" class="headerlink" title="자바스크립트의 프로토타입(Prototype)이란?"></a>자바스크립트의 프로토타입(Prototype)이란?</h2><p>자바스크립트에서는 <strong>Prototype Link</strong>와 <strong>Prototype Object</strong> 가 존재한다. 그리고 이 둘을 통틀어 <strong>Prototype</strong>이라 부른다.</p><p><strong>Prototype Link :</strong>  객체가 생성될 때 조상이었던 함수의 Prototype Object를 가리키며 객체안에서  <strong><strong>proto</strong></strong>  가 바로 그것이다.</p><p><strong>Prototype Object :</strong> 자기 자신의 <code>분신</code> 이며 자신을 원형으로 만들어질 다른 객체가 참조할 프로토타입이 된다. 즉 객체 자신을 이용할 다른 객체들이 프로토타입으로 사용할 객체가 <strong>Prototype Object</strong> 가 되는 것이다.</p><p>아래 예제를 살펴보자</p><figure class="codeblock codeblock--tabbed"><figcaption><span>예제1 코드</span><ul class="tabs"><li class="tab active">js</li></ul></figcaption><div class="tabs-content"><figure class="highlight js" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{ };</span><br><span class="line">   A.x=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">   };</span><br><span class="line">   A.prototype.x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">   };</span><br><span class="line">   <span class="keyword">var</span> B = <span class="keyword">new</span> A();</span><br><span class="line">   <span class="keyword">var</span> C = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">   B.x();</span><br><span class="line">   &gt; world</span><br><span class="line">   C.x();</span><br><span class="line">   &gt; world</span><br></pre></td></tr></tbody></table></figure></div></figure><p>B, C를 생성하기 위한 객체 원형 프로토타입은 A이다. 하지만 여기서 반드시 집고 넘어가야 하는 사실은 B,C는 A를 프로토타입으로 사용하기 위해 A의 <strong>Prototype Object</strong>를 사용한다는 것이다.<br>그리고 이 <strong>Prototype Object</strong>는 A가 생성될 당시의 정보 <code>var A = function () { };</code>는 비어있는 객체상태이기 때문에 A.x가 적용되지 않아 ‘hello’가 출력되지 않는다.<br>그러나 A.prototype.x를 통해 접근하게 되면 B,C 모두 A의 <strong>Prototype Object</strong> 를 참조하기 때문에 위의 결과에서 ‘world’ 가 출력되는 것이다.</p><p>위 예제를 상속모델 그림으로 표현하면 다음과 같다.<br><div class="figure center" style="width:100%;"><a class="fancybox" href="relation2.png" title="상속모델 표현도" data-caption="상속모델 표현도" data-fancybox="javascript"><img class="fig-img" src="relation2.png" style="width:100%;height:100%;" alt="상속모델 표현도"></a><span class="caption">상속모델 표현도</span></div><div style="clear:both;"></div></p><p>그림과 코드를 함께 보도록 하자.<br>코드의 첫 번째 줄에서 A Object가 생성되면서 A에 대한 <strong>Prototype Object</strong>가 생성된다.(자기 자신의 분신이 생성된다)<br>그림에선 가운데의 A 객체가 생성되고 그 아래 A에 대한 <strong>Prototype Object</strong>가 만들어지며 A 객체는 <strong>A Prototype Object</strong>를 가리킨다.<br>또한 <strong>A Prototype Object</strong>안의 Constructor를 보면 A 객체를 가리키고 있다. 즉 자신의 원형이 A객체라는 뜻이다.</p><p>2~4라인에서 A 객체의 속성 x에 함수를 대입하였다. 그림에서도 A 객체에 x속성이 추가된 것을 확인 할 수 있다.</p><p>5~7라인에서 <strong>A Prototype Object</strong>에 직접적으로 접근하여 함수를 할당하였다. 그림에서도 <strong>A Prototype Object</strong> 에 x속성이 존재하는 것을 확인 할 수 있다.</p><p>8~9라인에서는 A 객체를 기반으로 B, C객체를 만들었다. 자바스크립트는 프로토타입 기반이기 때문에 A 객체가 아니라 <strong>A Prototype Object</strong>를 참조하여 B, C 객체가 만들어지게 되는 것이다. 즉 그림에서 처럼 B, C객체는 <strong>A Prototype Object</strong>를 링크하게 된다.</p><p>이후 10, 12라인에서 B.x()와 C.x()를 호출하게되면 A객체의 x속성이 아니라 프로토타입기반으로 B,C가 생성되었으므로 <strong>A Prototype Object</strong> 의 x가 공유되어 ‘hello’가 아닌 ‘world’가 출력된다.</p><h2 id="자바스크립트의-프로토타입-체인-Prototype-Chain"><a href="#자바스크립트의-프로토타입-체인-Prototype-Chain" class="headerlink" title="자바스크립트의 프로토타입 체인(Prototype Chain)"></a>자바스크립트의 프로토타입 체인(Prototype Chain)</h2><p>프로토타입 체인이란 <strong>프로토타입을 상속해서 만들어지는 객체들간의 연관관계를 의미</strong> 한다. 위쪽 설명에서 <strong><strong>proto</strong></strong>는 <strong>Prototype Link</strong>를 의미하며 이를 따라 올라가보면 <strong>Object</strong> 객체의 <strong>Prototype Object</strong>에 다다른다.<br>그렇기 때문에 자바스크립트의 모든 객체는 <strong>Object</strong>객체로부터 파생된 자식들이며 기본적인 <strong>Object Prototype</strong>의 내장함수들이 자식들에게도 공유되는 것이다.(toString, hasOwnProperty등)</p><p>이러한 프로토타입 체인은 하위 객체에서 상위 객체의 프로퍼티와 메소드를 상속받는다. 사실 상속이 아니라 <strong>공유</strong>하고 있는 것이다.</p><p>아래의 예제와 표현도를 살펴보자</p><figure class="codeblock codeblock--tabbed"><figcaption><span>예제2 코드</span><ul class="tabs"><li class="tab active">js</li></ul></figcaption><div class="tabs-content"><figure class="highlight js" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{ };</span><br><span class="line">   A.prototype.x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">   };</span><br><span class="line">   <span class="keyword">var</span> B = <span class="keyword">new</span> A();</span><br><span class="line">   <span class="keyword">var</span> C = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">   B.x();</span><br><span class="line">   &gt; hello</span><br><span class="line"></span><br><span class="line">  C.x();</span><br><span class="line">  &gt; hello</span><br><span class="line"></span><br><span class="line">  A.prototype.x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  B.x();</span><br><span class="line">  &gt; world</span><br><span class="line"></span><br><span class="line">  C.x();</span><br><span class="line">  &gt; world</span><br></pre></td></tr></tbody></table></figure></div></figure><div class="figure center" style="width:100%;"><a class="fancybox" href="relation3.png" title="상속모델 표현도" data-caption="상속모델 표현도" data-fancybox="javascript"><img class="fig-img" src="relation3.png" style="width:100%;height:100%;" alt="상속모델 표현도"></a><span class="caption">상속모델 표현도</span></div><div style="clear:both;"></div><p>위쪽에서 살펴보았던 예제와 비슷하다. 객체 A를 만들고 A의 <strong>Prototype Object</strong>에 x 속성을 추가하였다. 이후 B, C객체는 <strong>A의 Prototype Object</strong>를 참조하였다.<br>5~12라인에서 B,C 객체를 만들고 x속성을 호출하게 된다. 그러나 B,C객체에는 x속성이 없다.<br>따라서 프로토 타입 체이닝에 의해 상위 객체의 속성을 찾게 되며 즉,<br><strong>A의 Prototype Object</strong>에 있는 x을 찾아 ‘hello’가 출력된다.<br>이러한 방법으로 만약 찾으려는 x가 없는 경우 계속해서 상위객체를 찾는다.<br>상위객체를 참조하여도 해당 속성이 없다면 마지막에는 <strong>Object의 Prototype</strong> 객체까지 올라가게 된다.<br>그래도 없다면 undefiend를 리턴하게 된다.</p><hr><p>이번 공부 내용을 통해 그동안 뜬구름만 잡았던 프로토타입에 대해 깊숙하게 이해 할 수 있었다.</p><h2 id="참조링크"><a href="#참조링크" class="headerlink" title="참조링크"></a>참조링크</h2><p><a href="https://medium.com/@bluesh55/javascript-prototype-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-f8e67c286b67" target="_blank" rel="noopener">Javascript  프로토타입 이해하기 – 오승환 – Medium</a><br><a href="http://insanehong.kr/post/javascript-prototype/" target="_blank" rel="noopener">Javascript 기초 - Object prototype 이해하기 |  Insanehong’s Incorrect Note</a></p>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Javascript Prototype에 대해 정리해보았다.&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://ksw1652.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://ksw1652.github.io/tags/Javascript/"/>
    
      <category term="Prototype" scheme="http://ksw1652.github.io/tags/Prototype/"/>
    
  </entry>
  
  <entry>
    <title>Codiliy Lesson 1 Iteration</title>
    <link href="http://ksw1652.github.io/2018/07/26/codility-lesson-01/"/>
    <id>http://ksw1652.github.io/2018/07/26/codility-lesson-01/</id>
    <published>2018-07-25T15:00:00.000Z</published>
    <updated>2018-08-11T19:15:47.352Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h1 id="Codility-Lesson-1-Iteration"><a href="#Codility-Lesson-1-Iteration" class="headerlink" title="Codility Lesson 1 Iteration"></a>Codility Lesson 1 Iteration</h1><p>코딩테스트를 위해 오늘 부터 알고리즘 문제를 풀어보려 한다. 우선 <strong>Codility</strong> 사이트의 테스트 문제들을 풀어봤는데 생각보다 어렵다;;;<br>테스트 문제는 완료하지도 못한채로 제출을 해버렸다..</p><p>오늘부터 <strong>Codility</strong> 사이트의 Lession 문제들을 차근차근 풀어보려 한다. 더불어 예전에 조금 깨작? 거렸던 Cordwars도 풀어볼 것이다.<br>개인적으로 알고리즘 문제를 풀 땐 연습장에 직접 써보면서 풀어가는데, 채용시 코테에서 연습장을 쓸 수 있을지는 의문이다. 이때문에 컴퓨터 상에서 풀어보는 연습도 필요하다.<br>그리고 <strong>Codility</strong>의 경우 run task를 할 경우 테스트 케이스의 결과만 보여주기 때문에 내부에서 어떻게 돌아가는지 파악하기 어렵다…<br>그래서 찾아낸 방법은 jsFiddle로 코드를 작성하면서 컴파일을 돌리고, 결과 코드를 복붙! 하면 좀 더 시간을 단축 시킬 수 있을 것 같다.<br>오늘 부터 한 문제씩 업로드 하고 내가 풀었던 코드들도 같이 올릴 것이다.</p><hr><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><blockquote><p>A binary gap within a positive integer N is any maximal sequence of consecutive zeros that is surrounded by ones at both ends in the binary representation of N.</p><p>For example, number 9 has binary representation 1001 and contains a binary gap of length 2. The number 529 has binary representation 1000010001 and contains two binary gaps: one of length 4 and one of length 3. The number 20 has binary representation 10100 and contains one binary gap of length 1. The number 15 has binary representation 1111 and has no binary gaps. The number 32 has binary representation 100000 and has no binary gaps.</p><p>Write a function:</p><p>function solution(N);</p><p>that, given a positive integer N, returns the length of its longest binary gap. The function should return 0 if N doesn’t contain a binary gap.</p><p>For example, given N = 1041 the function should return 5, because N has binary representation 10000010001 and so its longest binary gap is of length 5. Given N = 32 the function should return 0, because N has binary representation ‘100000’ and thus no binary gaps.</p><p>Assume that:</p><p>N is an integer within the range [1..2,147,483,647].<br>Complexity:</p><p>expected worst-case time complexity is O(log(N));<br>expected worst-case space complexity is O(1).</p></blockquote><hr><p>문제해설 : 주어진 Integer N이 있고, 이를 이진수로 변환하였을 때 1과 1사이의 0의 갯수를 gap이라 한다.<br>예를 들어 9는 이진수로 1001이며 gap의 길이는 2가 된다.<br>숫자 529의 경우 이진수로 1000010001이며 이 경우에는 gap이 4와 3이다.<br>function solution(N);<br>함수 solution에서 N이 파라미터로 주어졌을 때 가장 긴 gap값을 찾아라.<br>단 gap이 존재하지 않을 경우 0을 리턴해야 한다. 예를들어 N = 32인 경우 이진수로 100000이며 이때의 gap은 0이다.<br>N은 [1..2,147,483,647]의 범위 값을 가진다.<br>복잡도 :<br>최악의 시간 복잡도 케이스는 O(log(N)) 이다.<br>최악의 공간 복잡도 케이스는 O(1) 이다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">js</li></ul></figcaption><div class="tabs-content"><figure class="highlight js" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">N</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> binaryValue = (N &gt;&gt;&gt; <span class="number">0</span>).toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> innerCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> gap = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt; binaryValue.length; i++) {</span><br><span class="line">    <span class="keyword">if</span>(binaryValue[i] == <span class="number">0</span>) {</span><br><span class="line">      innerCount++;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span>(innerCount &gt; gap) {</span><br><span class="line">      gap = innerCount;</span><br><span class="line">      }</span><br><span class="line">  innerCount = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> gap;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><h2 id="답안-해설"><a href="#답안-해설" class="headerlink" title="답안 해설"></a>답안 해설</h2><blockquote><p>우선 주어진 값을 이진값으로 변환하기 위해 toString()을 사용하였다. 이때 인자로 들어간 <strong>‘2’</strong> 값은 optional인데 2일 경우 binary 문자열로 리턴해준다.</p><p>이렇게 변환된 binary문자열은 (해당 문자열의 길이 - 1) 만큼 반복문을 돌게된다.</p><p>각 인덱스 순서대로 값을 확인하면서, 값이 0일 경우, 반복되는 0의 갯수를 count하는<br>innerCount라는 값이 증가하게 되고 1일 경우 현재의 innerCount와 이전의 gap을 비교하여 현재의 innerCount, 즉 새로 count 된 gap이 클경우 이를 gap에 할당한다.</p><p>이후 innerCount는 초기화 되며 다시 gap을 찾기위해 count 한다.</p></blockquote><h2 id="실행결과"><a href="#실행결과" class="headerlink" title="실행결과"></a>실행결과</h2><div class="figure center" style="width:100%;"><a class="fancybox" href="codility_lesson1.png" title="Lesson 1 Codility Result" data-caption="Lesson 1 Codility Result" data-fancybox="codility"><img class="fig-img" src="codility_lesson1.png" style="width:100%;height:100%;" alt="Lesson 1 Codility Result"></a><span class="caption">Lesson 1 Codility Result</span></div><div style="clear:both;"></div>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Codility 사이트의 lesson을 한 단계씩 풀어가면서 이에 대한 문제와 해설을 포스팅 하려 한다.&lt;br&gt;
    
    </summary>
    
      <category term="코딩테스트" scheme="http://ksw1652.github.io/categories/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
    
      <category term="이직" scheme="http://ksw1652.github.io/tags/%EC%9D%B4%EC%A7%81/"/>
    
      <category term="코딜리티" scheme="http://ksw1652.github.io/tags/%EC%BD%94%EB%94%9C%EB%A6%AC%ED%8B%B0/"/>
    
      <category term="코테" scheme="http://ksw1652.github.io/tags/%EC%BD%94%ED%85%8C/"/>
    
  </entry>
  
</feed>
